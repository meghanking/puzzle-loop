(defun slither ()
	
	(loop
		(printmap)
		(dotstring)
		(tilestring)
		(statestring) 
		
		(progn 
			(format t "Make another move? y/n: ")
			(Setq answer (read))
		)
		
		(when 
			(cond
				(
					(equal answer 'y)
					(progn 
						(format t "Your next move it: ")
						(makemove (read) (read) (read))
					)
					(checkallvalidity)
				)
				(t
					(return "Thanks for playing!")
				)
			)
		)

		(when isboardvalid 
        	(if (playgameagain)
        		(slither)
        		(return "Thanks for playing!")
        	)
        	(return nil)
        )
    )
)

;;------------------------

(defun playgameagain ()
  (if (y-or-n-p "You've won! Do you want to play another board?") 
      (progn (format t "Choose a map:~%~{~a, ~}" maplist)
             (makegameboard (read)) t)
             nil
	)
)


;;------------------------

(defun isinvalidrownumber (row)

	(and (> row 0) (<= row (list-length (eval (car currentmap)))))
)


;;------------------------

(defun isinvalidcolnumber (col)

	(and (> col 0) (<= col (list-length (car (eval (car currentmap))))))
)


;;------------------------

(defun isinvalidsideletter (side)

	(cond
		(
			(equal side 't)
			t
		)
		(
			(equal side 'b)
			t
		)
		(
			(equal side 'r)
			t
		)
		(
			(equal side 'l)
			t
		)
		(
			t
			nil
		)
	)
)

;;------------------------

(defun makemove (rownum colnum sidetoplaceline)
	
	(setq thingy 
		(and 
			(isinvalidsideletter sidetoplaceline) 
			(isinvalidcolnumber colnum) 
			(isinvalidrownumber rownum)
		)
	)

	(if thingy
		(setq lineinquestion (getplacementreference rownum colnum sidetoplaceline))
	)
	
	(if thingy
		(cond
			( 
				(equal lineinquestion '(empty))
				(setq linenum (+ 1 linenum))
				(setq movelist (append movelist (list (list rownum colnum sidetoplaceline))))
				(rplaca lineinquestion 'line)
			)
			(
				t
				(print "Not a valid placement")
			)
		)
		(print "Bad input")
	)
	(checkallvalidity)
)

;;------------------------

(defun checkallvalidity ()

	(setq validitychecks (list (checkdots dotrepmap) (checktiles tilerepmap)))
	(if
		(equal (member nil validitychecks) nil)
		(isclosedcircut)
	)	
	isboardvalid
)

;;------------------------

(defun checkdots (dotrepmap)

	(resetaredotsvalid)	
			
	(loop for i from 1 to (list-length dotrepmap) collect
		(mapcar #'checkdot (elt dotrepmap (- i 1)))

	)
			
	aredotsvalid
)


;;------------------------

(defun checktiles (tilerepmap)

	(resetaretilesvalid)

	(loop for i from 1 to (list-length tilerepmap) collect
		(mapcar #'checktile (elt tilerepmap (- i 1)))

	)

	aretilesvalid
)


;;------------------------
(defun resetaredotsvalid ()

(setq aredotsvalid t)

)

;;------------------------
(defun aredotsvalid ( isitthough)

(setq aredotsvalid (and isitthough aredotsvalid))

)

;;------------------------
(defun resetaretilesvalid ()

(setq aretilesvalid t)

)
;;------------------------
(defun aretilesvalid ( isitthough)

(setq aretilesvalid (and isitthough aretilesvalid))

)


;;------------------------

(defun checkdot ( dottocheck )

	(setq countoflines (count '(line) dottocheck :test #'equal))
	(setq countofxs ( + (count '(xx) dottocheck :test #'equal) (count '(x) dottocheck :test #'equal)))
	(setq countofemptys (count '(empty) dottocheck :test #'equal))

	(cond
		(
			(equal countoflines 4) 
			;;BAD
			(aredotsvalid nil)
		)
		(
			(equal countoflines 3) 
			;;BAD
			(aredotsvalid nil)
		)
		(
			(equal countoflines 2)
			;;OKAY
			;;if some empty spots
			;;set all the other lines to x's
			(aredotsvalid t)
		)
		(
			(equal countoflines 1)
			 ;;BAD
			 (aredotsvalid nil)
		)
		(
			t
			;;OKAY
			;;if has any x's, set all the lines to x's
			(aredotsvalid t)
		)
	)	
)

;;------------------------

(defun checktile ( tiletocheck )

	(if (equal (car tiletocheck) '@)
		(setq numberintile nil)
		(setq numberintile (car tiletocheck))
	)
	
	
	(setq countoflines (count '(line) tiletocheck :test #'equal))
	(setq countofxs ( + (count '(xx) tiletocheck :test #'equal) (count '(x) tiletocheck :test #'equal)))
	(setq countofemptys (count '(empty) tiletocheck :test #'equal))

	(cond
		( (equal numberintile nil)
			(aretilesvalid t)
		)
		(
			(equal countoflines numberintile) 
			;;GOOD
			;;is some empty spots
			;;set all the other lines to x's
			(aretilesvalid t)
		)
		(
			(< countoflines numberintile) 
			;;can be good or bad or ugly
			
			(cond
				((equal countofemptys (- numberintile countoflines))
					;;GOOD
					;;is some empty spots
					;;set all the other lines to x's
					(aretilesvalid nil)
				)
				((> countofemptys 0)
					;;fine
					(aretilesvalid nil)
				)
				(t
					;;if all others are x's
					;;BAD
					;;which could happen because corners or something
					;;bad juju
					(aretilesvalid nil)
				)
			)
		)
		(
			t
			;;BAD
			;;CANNOT HELP
			;;BAD BAD BAD
			(aretilesvalid nil)
		)
	)	
	aretilesvalid
)

;;------------------------

(defun getplacementreference( rownum colnum sidetoplaceline ) 

		(setq rownum (convertcontenttolinerow rownum))
		
	
		(cond
			(
				(equal sidetoplaceline 'T)
				(setq rownum (- rownum 1))
			)
			(
				(equal sidetoplaceline 'B)
				(setq rownum (+ rownum 1))
			)		
		)
	
		(cond
			(
				(equal sidetoplaceline 'R)
				(setq  colnum (+ colnum 1))
			)
			(
				(equal sidetoplaceline 'T)
				(setq colnum (+ colnum 1))
			)
			(
				(equal sidetoplaceline 'B)
				(setq colnum (+ colnum 1))
			)	
		)
	
		(elt (elt linerepmap (- rownum 1)) (- colnum 1))

)


;;------------------------

;;assuming that the dots and tiles are all valid before calling this
(defun isclosedcircut ()

	(cond
		(
			(< linenum 4)
			(setq isboardvalid nil)
		)
		(t
			(findfirstline)		;;firstline will now be set with some 
			(Setq linecount 0)
			(Setq nextline nil)
			(setq currentline nil)
			(findnextline)
			(setq isboardvalid (equal linecount linenum))
			
		)
	)	
	
	isboardvalid	
)


;;------------------------

(defun findfirstline ()

	(setq firstline nil)

	(loop for i from 2 to (- (list-length linerepmap) 1) do
		(loop for j from 1 to (list-length (elt linerepmap (- i 1))) do
			(cond
				(
					(equal (elt (elt linerepmap (- i 1)) (- j 1)) '(line))
					(setq firstline (list i j))
					(Setq j (list-length (elt linerepmap (- i 1))))
					(setq i (- (list-length linerepmap) 1))
				)
			)
		)
		
	)
	firstline
)

;;------------------------
(defun findnextline ()

	(cond
		(
			(equal linecount 0)
			(setq currentline firstline)
			(setq nextline (car (findlinenexttoyou currentline nil)))
			
			(setq linecount (+ 1 linecount))
			(findnextline)
		)
		(	
			(equal firstline nextline)
			linecount
		)
		(t
			(setq templine (car (findlinenexttoyou nextline currentline)))
			(setq currentline nextline)
			(setq nextline templine)
			(setq linecount (+ 1 linecount))
			(findnextline)
		)
	)
	linecount	
)

;;------------------------
(defun findlinenexttoyou (lineyouare linetoomit)

	(if
		(equal (mod (Car lineyouare) 2) 0)
		(Setq linestoreturn
			(findlinenexttoyoueven lineyouare)
		)
		(setq linestoreturn 
			(findlinenexttoyouodd lineyouare)
		)
	)
	(setq linestoreturn (remove linetoomit linestoreturn :test #'equal))
)

;;------------------------
(defun findlinenexttoyouodd (lineyouare)

	(setq listtoreturn '())
	
	
	(if
		(returnifline (- (car lineyouare) 1) (cadr lineyouare))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(- (car lineyouare) 1) 
					(cadr lineyouare)
				))
			)
		)
	)
	(if
		(returnifline (+ (car lineyouare) 1) (cadr lineyouare))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(+ (car lineyouare) 1) 
					(cadr lineyouare)
				))
			)
		)
	)
	(if
		(returnifline (- (car lineyouare) 1) (+ 1 (cadr lineyouare)))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(- (car lineyouare) 1) 
					(+ 1 (cadr lineyouare))
				))
			)
		)
	)
	(if
		(returnifline (+ (car lineyouare) 1) (+ 1 (cadr lineyouare)))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(+ (car lineyouare) 1) 
					(+ 1 (cadr lineyouare))
				))
			)
		)
	)
	(if
		(returnifline (+ (car lineyouare) 2) (cadr lineyouare))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(+ (car lineyouare) 2) 
					(cadr lineyouare)
				))
			)
		)
	)
	(if
		(returnifline (- (car lineyouare) 2) (cadr lineyouare))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(- (car lineyouare) 2) 
					(cadr lineyouare)
				))
			)
		)
	)
	listtoreturn
)

;;------------------------
(defun findlinenexttoyoueven (lineyouare)

	(setq listtoreturn '())
	
	
	(if
		(returnifline (- (car lineyouare) 1) (cadr lineyouare))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(- (car lineyouare) 1) 
					(cadr lineyouare)
				))
			)
		)
	)
	(if
		(returnifline (+ (car lineyouare) 1) (cadr lineyouare))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(+ (car lineyouare) 1) 
					(cadr lineyouare)
				))
			)
		)
	)
	(if
		(returnifline (- (car lineyouare) 1) (- (cadr lineyouare) 1))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(- (car lineyouare) 1)
					(- (cadr lineyouare) 1)
				))
			)
		)
	)
	(if
		(returnifline (+ (car lineyouare) 1) (- (cadr lineyouare) 1))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(+ (car lineyouare) 1) 
					(- (cadr lineyouare) 1)
				))
			)
		)
	)
	(if
		(returnifline (car lineyouare) (- (cadr lineyouare) 1))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(car lineyouare) 
					(- (cadr lineyouare) 1)
				))
			)
		)
	)
	(if
		(returnifline (car lineyouare) (+ (cadr lineyouare) 1))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(car lineyouare) 
					(+ (cadr lineyouare) 1)
				))
			)
		)
	)
	listtoreturn
)

;;------------------------
(defun returnifline (rownumber columnnumber)

	(equal (elt (elt linerepmap (- rownumber 1)) (- columnnumber 1)) '(line))
)

;;------------------------
(defun statestring ()
	(cond
		( isboardvalid 
			(print "Game is over and the board is correct.")
			maplist
		)
		( t
			(print "Board is still incorrect or not completed.")
		)
	)
)
;;------------------------
(defun dotstring ()
	(if aredotsvalid 
		(print "Intersections are valid")
		(print "Some intersections are not valid")
	)
)
;;------------------------
(defun tilestring ()
	(if aretilesvalid 
		(print "Tiles are valid")
		(print "Some tiles are not valid")
	)
)


;;------------------------

(defun convertlinetocontentrow (number)
	(/ (- number 1) 2 )
)

;;------------------------

(defun convertcontenttolinerow (number)
	(+ (* number 2) 1 )
)


;;------------------------
(defun makemap (mapname mapcontents)

	 (set mapname mapcontents)
	 (setq maplist (append maplist (list mapname)))
 )

;;------------------------

(defun makegameboard (mapname) 

	(setq rownum (list-length (eval mapname)) )
	(setq colnum (list-length (car (eval mapname))))
	(setq linerepmap (makelinerepmap rownum colnum))
	(setq dotrepmap (makedotrepmap linerepmap))
	(setq tilerepmap (maketilerepmap dotrepmap (eval mapname)))
	(setq linenum 0)
	(setq aredotsvalid nil)
	(setq aretilesvalid nil)
	(setq isboardvalid nil)
	(setq movelist '())
	(setq statestring "Let the game begin")
	;;(setq linestring "Let the game begin")
	(setq currentmap (list mapname 'linerepmap 'dotrepmap 'tilerepmap 'movelist 'linenum))
	(checkallvalidity)
	(string "The game map is now set. Enter (slither) to start the game.")
)



;;------------------------

(defun makelinerepmap (rownum colnum)

	(loop for i from 1 to (+ (* rownum 2) 3) collect
		(cond 
			((or (equal 1 i) (equal (+ (* rownum 2) 3) i))
				(make-sequence 'list (+ 1 colnum) :initial-element '(xx)
	)
			)
			((equal (mod i 2) 0)
				(append 
					(list '(xx)) 
					(loop for i from 1 to colnum collect
					(list 'empty))
					(list '(xx))
				)
			)
			(t 
				(loop for i from 0 to colnum collect 
					(list 'empty)
				)
			)
		)
	)
)

;;------------------------

(defun createdot (numberrow numbercol)		
	(list 
		(elt (elt linerepmap (- numberrow 1)) (- numbercol 1))
	
		(elt (elt linerepmap numberrow) numbercol)
	
		(elt (elt linerepmap (+ numberrow 1)) (- numbercol 1))
	
		(elt (elt linerepmap numberrow) (- numbercol 1))
	)
)

;;------------------------

(defun makedotrepmap (linerepmap)

	(remove nil
		(setq listofdots
			(loop for i from 1 to (- (list-length linerepmap) 1) collect
				(cond
						((equal (equal (mod i 2) 0) NIL)	 	
						
						(loop for j from 1 to (+ 1 colnum) collect
							(createdot i j))
						)
				)
			)
		)
	)
)



;;------------------------

(defun maketilerepmap (dotrepmap mapcontents)
 
	(loop for i from 1 to (list-length mapcontents) collect
		(loop for j from 1 to (list-length (car mapcontents)) collect
			(list (elt (elt mapcontents (- i 1)) (- j 1))

			(elt (elt (elt dotrepmap (- i 1)) (- j 1)) 1)

			(elt (elt (elt dotrepmap i) j) 0)
		
			(elt (elt (elt dotrepmap i) j) 3)
		
			(elt (elt (elt dotrepmap (- i 1)) (- j 1)) 2)
			
			)
		)	
	)
 )


;;------------------------

(defun getprintmap (currentmap)

	(setq columnnumbered nil)

		(loop for j from 0 to (- (list-length (car (eval (cadr currentmap)))) 1) do
			(Setq columnnumbered (append columnnumbered (list j '-)))
		)
	
	(setq result
		(loop for i from 2 to (- (list-length (eval (cadr currentmap))) 1) collect
			(cond
				((equal 0 (mod i 2))
				 	(append (list '-)(printevenrow i (cadr currentmap)))
				)
				(t
					(append (list (/ (- i 1) 2))(printoddrow i (cadr currentmap) (car currentmap)))
				)
			)
		)
	)
	
	(setq resultresult (append (list columnnumbered) result))
)

;;------------------------

(defun convertsymboleven (symbol)

	(cond
		((equal '(line) symbol)
			'=
		)(t 
			(convertsymbolany symbol)
		)
	)
)

;;------------------------

(defun convertsymbolodd (symbol)

	(cond 
		((equal '(line) symbol)
			'i
		)
		(t 
			(convertsymbolany symbol)
		)
	)
)

;;------------------------

(defun convertsymbolany (symbol)
	
	(cond 
		((equal '(xx) symbol) 
			'x
		)
		((equal '(x) symbol) 
			'*
		)
		((equal '(empty) symbol)
			'*
		)
	)
)

;;------------------------

(defun printevenrow (rowtoprint linerepmap)
	(setq lines (mapcar #'convertsymboleven (elt (eval linerepmap) (- rowtoprint 1))
	))
	 
	(setq result '())
	
	(loop for i from 1 to (- (list-length lines) 2) do
		(setq result 
			(append result 
				(list 
					'+
					(elt lines i)
				)
			)
		)
	)
	
	(append result (list '+))
)

;;------------------------
	
(defun printoddrow (rowtoprint linerepmap mapname)
	(setq symbols 
		(mapcar #'convertsymbolodd 
			(elt (eval linerepmap) (- rowtoprint 1)
			)
		)
	)
	
	(setq mapcontentsrow (elt (eval mapname) (- (convertlinetocontentrow rowtoprint) 1 )))
	
	(setq result '())
	
	(loop for i from 1 to (list-length mapcontentsrow) do
		(setq result 
			(append result 
				(list 
					(elt symbols (- i 1))
					(elt mapcontentsrow (- i 1))
				)
			)
		)
	)
	
	(append result (last symbols 1))
)


;;------------------------

(defun printmap ()

	(setq resultresult (getprintmap currentmap))
	
	
	(loop for i from 0 to (- (list-length resultresult) 1 ) do
		(print (elt resultresult i))
	)
)

;;------------------------
(defun showgamerules ()
	(format t 
"Slither Link's Puzzle Loop is a game of wits, between you and the rules I will describe 
here.

The quote below is from Slither Link's exact description copied from their website:

\"The rules are simple. You have to draw lines between the dots to form a single loop 
without crossings or branches. The numbers indicate how many lines surround it.\"


To accomplish this monumental task, the following wil explain how, coding wise, things 
needed to accomplish such game play by my implementation such as which function calls to 
make, how to construct a map, and specifying moves on the board.


If any questions, comments, or concerns, feel free to contact me:
	Meghan King
	meghantking67@gmail.com

using the subject: Slither's Puzzle Loop Question.



Content sections are in this order:
	Seeing the game rules
	Making a map
	Selecting a map to play
	Printing a map before gameplay
	Starting a game
	Making a move
	Winning the game

==========================================================================================
Seeing the game rules:

	Game rules can be found in the README.txt file paired with the Silther implementation.
	
	Game rules can also be printed once the game is loaded by calling the function
	'showgamerules' which has no arguments
	
		CG-USER(27): (showgamerules)

		The output of this is omitted in this case.

==========================================================================================
Making a map:

	Maps are structured as a a list. Each sublist is the rows, in order from top to
	bottom, with their contents being each element (or tile) in the corresponding column 
	of that row. Tiles that have a number should be specified with that number 
	(0, 1, 2, 3, or 4). Tiles that have no number should be specified with the @ char.

	Once a map is made, the name of the map is added to a list of all the maps created, 
	called 'maplist'. The 'maplist' is returned each time a new map is created.
	To create a map, use the function 'makemap' which takes two arguments:
		1. the name of map
		2. the contents of the map in the correct form
		
	Please only input maps that have a proper solution.



	Example of making a map:

		(+ * + * +) 
		(* 1 * 0 *) 
		(+ * + * +) 
		(* 3 * @ *) 
		(+ * + * +) 
		(* 2 * @ *) 
		(+ * + * +) 

		The map above can be created by entering:

		CG-USER(17): (makemap 'mapexample '((1 0) (3 @) (2 @)))
		(MAP1 MAP2 MAP3 MAP4 MAP5 MAP6 MAPEXAMPLE)
		

==========================================================================================
Selecting a map to play:

	Many maps can be made, but only one map can be the game board at a time. 
	To select a game board, use the function 'makegameboard' with one arguement:
		1. the name of the map
		
			CG-USER(27): (makegameboard 'mapexample)
			
			(+ * + * +) 
			(* 1 * 0 *) 
			(+ * + * +) 
			(* 3 * @ *) 
			(+ * + * +) 
			(* 2 * @ *) 
			(+ * + * +) 
			\"This is now the game map. Enter (slither) to start the game.\"
	
	
==========================================================================================
Printing a map before gameplay:

	A map can be printed with either the contents that were input by the user, or in 
	the format seen in \"Example of making a map\".
	
	To print with the contents input by ther user, enter the name of the map.
	
			CG-USER(17): mapexample
			((1 0) (3 @) (2 @))

	To print with the contents in the playable format, use a function 'printmap' which 
	takes no arguments. 
	However, there MUST be a game board already set using 
	'makegameboard' function.

			CG-USER(37): (printmap)

			(+ * + * +) 
			(* 1 * 0 *) 
			(+ * + * +) 
			(* 3 * @ *) 
			(+ * + * +) 
			(* 2 * @ *) 
			(+ * + * +)


==========================================================================================
Starting a game:

	After selecting a map to play (see the section of the same name above for details),
	use the function 'slither' with no arguments. 
	However, there MUST be a game board already set using 'makegameboard' function.

			CG-USER(38): (slither)

			(+ * + * +) 
			(* 1 * 0 *) 
			(+ * + * +) 
			(* 3 * @ *) 
			(+ * + * +) 
			(* 2 * @ *) 
			(+ * + * +) 
			\"Intersections are valid\" 
			\"Some tiles are not valid\" 
			\"Board is still incorrect or not completed.\" Make another move? y/n: 
			
			
==========================================================================================	
Making a move:

	After starting a game, you will be prompted if you would liek to make another move.
	Entering the character y will allow you to enter a move.
	Entering anything else will allow you to exit the game.
	
			\"Board is still incorrect or not completed.\" Make another move? y/n: y
			Your next move it: 
	
	To enter a move, specify the row number, column number, and the side you would like 
	the lined to be placed (T top, L left, B bottom, R right)
	
			Your next move it: 2 2 L
			
			(+ * + * +) 
			(* 1 * 0 *) 
			(+ * + * +) 
			(* 3 I @ *) 
			(+ * + * +) 
			(* 2 * @ *) 
			(+ * + * +) 
			\"Some intersections are not valid\" 
			\"Some tiles are not valid\" 
			\"Board is still incorrect or not completed.\" Make another move? y/n
	
	This will draw a line in the place that you have specified: 
		the second row, second column, Left side
		
	This same move could have been accomplished with 2 1 R.


==========================================================================================
Restarting a game after exit:

	A game that was currently being played, but you chose to make no more moves (either
	by accident or on purpose) can be reset to the state you left it at by using the
	function 'slither'
	
			CG-USER(23): (slither)

			(+ = + * +) 
			(* 2 * 2 *) 
			(+ * + * +) 
			(* 2 * 2 *) 
			(+ * + * +) 
			\"Some intersections are not valid\" 
			\"Some tiles are not valid\" 
			\"Board is still incorrect or not completed.\" Make another move? y/n: 

==========================================================================================
Winning a game:

	A game is won by completing the board following the Slither's Puzzle Loop rules.
	The game should correctly determine if you have completed the board successfully.
	A dialog box will ask you if you want to play another board. 
	, you will be prompted to ask the play another map.
	A list of all the map names will be printed, and you can enter which map you would 
	like to select.
	
			
			You've won! Do you want to play another board?
			Choose a map: map1 map2 map3 map4 map5 map6 mapexample
			
	Type in the map name, and the process starts all over again.
	
	
================================== Thanks for playing! ==================================")
)



;;------------------------
(setq maplist '())

(makemap 'map1  '((2 2) (2 2)))
(makemap 'map2 '((1 0) (3 @) (2 @)))
(makemap 'map3 '((2 2 @ @ @) (@ 2 @ 2 2) (@ @ 3 @ @) (@ @ 0 @ @) (3 @ 3 @ @)) )
(makemap 'map4 '((4)))
(makemap 'map5 '((@ @) (3 3)))

(makegameboard 'map1)