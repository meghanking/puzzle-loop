;;-----------------------
(defun drawLineAI (linetodraw message isGuess previouscurrentmap )
	
	(rplaca (car linetodraw) 'line)
	(addtomovelist (cadr linetodraw) 'line message)
	(isAInotstuck t)
	(if isguess
		(addtoguesslist previouscurrentmap linetodraw)
	)	

	;;do "caused close loop" check
)

;;-----------------------
(defun banLineAI (linetoban message isGuess previouscurrentmap )
	
	(rplaca (car linetoban) 'x)
	(addtomovelist (cadr linetoban) 'x message)
	(isAInotstuck t)
	(if isguess
		(addtoguesslist previouscurrentmap linetoban)
	)
	
)

;;-----------------------
(defun deepcopyCurrentGame (currentmap)

	(setq aredotsvalid nil)
	(setq aretilesvalid nil)
	(setq isboardvalid nil)
	
	(setq newmap
		
		(list 
			(car currentmap)
			(deepcopylinerepmap (cadr currentmap))
		)
	)
	(setq newmap (append newmap (list (makedotrepmap (cadr newmap) (list-length (car (eval (car currentmap))))))))
	(Setq newmap (append newmap (list (maketilerepmap  (caddr newmap) (eval (car currentmap))))))
	(Setq newmap (append newmap (list (car (cddddr currentmap)))))
	(Setq newmap (append newmap (list nil)))
	(setq gamemaps (append (list newmap) gamemaps))
	
)

;;-----------------------
(defun deepcopylinerepmap (original)

	(loop for i from 1 to (list-length original) collect	
		(cond
			;;first or last row
			((or (equal 1 i) (equal (list-length original) i))
				(make-sequence 'list (list-length (car original)) :initial-element '((xx)))
			)
			;;middlerowseven
			((equal (mod i 2) 0)
				(middleRowEvenLineRepMapDeepCopy (elt original (- i 1)))
			)
			;;middlerows odd
			(t 
				(middleRowOddLineRepMapDeepCopy (elt original (- i 1)))
			)
		)
	)
)

;;-----------------------
(defun middleRowEvenLineRepMapDeepCopy (originalrow)
	
	(append 
		(list '((xx))) 
		(loop for j from 1 to (- (list-length originalrow) 2) collect
			(list (list (caar (elt originalrow j))) (cadr (elt originalrow j)))
		)
		(list '((xx)))
	)
)

;;-----------------------
(defun middleRowOddLineRepMapDeepCopy (originalrow)

	(loop for j from 0 to (- (list-length originalrow) 1) collect
		(list (list (caar (elt originalrow j))) (cadr (elt originalrow j)))
	)
)

;;-----------------------
(defun findintersectiontoguesswith (dotrepmap restrictionlist)

	(Setq nothavefallback t)
	(Setq fallback nil)
	(setq changing nil)
	
	(loop for i from 0 to (- (list-length dotrepmap) 1) do
		(loop for j from 0 to (- (list-length (elt dotrepmap i)) 1) do
			(setq intersectionguess (elt (elt dotrepmap i) j))
						
			(cond 
				(
					(and (not (equal (mmember '(line) (elt (elt dotrepmap i) j)) nil)) (not (equal (mmember '(empty) (elt (elt dotrepmap i) j)) nil)))
					(cond
						( (equal (mmember (cadr (mmember '(empty) (elt (elt dotrepmap i) j))) restrictionlist) nil)
							(Setq changing (mmember '(empty) (cdr (memember '(empty) (elt (elt dotrepmap i) j) ))))
							(Setq j (- (list-length (elt dotrepmap i)) 1))
							(Setq i (- (list-length dotrepmap) 1))
						)
						( t
							(Setq changing (mmember '(empty) (elt (elt dotrepmap i) j)))
							(Setq j (- (list-length (elt dotrepmap i)) 1))
							(Setq i (- (list-length dotrepmap) 1))
						)
					)
				)
				(	(and nothavefallback (not (equal (mmember '(empty) (elt (elt dotrepmap i) j)) nil)))
					(setq fallback (mmember '(empty) (elt (elt dotrepmap i) j)))
					(setq nothavefallback nil)
				)
			)
		)
	)
	(if (equal changing nil)
		fallback
		changing
	)
)

;;-----------------------
;;gets the list with that line as the first member
(defun memember (thingtomember thingtomemberon)
	
	(Setq result nil)
	(loop for i from 0 to (- (list-length thingtomemberon) 1)  do
		(cond
			(	
				(listp (elt thingtomemberon i))
				(cond
					(
						(equal nil (member thingtomember (elt thingtomemberon i) :test #'equal))
						(setq result nil)
					)
					(
						t
						(Setq result thingtomemberon)
						(loop for j from 1 to i do
							(setq result (cdr result))
						)
						(setq i (list-length thingtomemberon))
					)
				)
			)
		)
	)
	result
)

;;-----------------------
;;gets the line with that thing
(defun mmember (thingtomember thingtomemberon)

	(car (memember thingtomember thingtomemberon))
)

;;-----------------------
(defun currentmap (currentmap)

	(print (Car currentmap))
	
	(print "Line Rep Map")
	(if (equal (cadr currentmap) nil)
		(print "There is no linerepmap")
		(printlinerepmap (cadr currentmap))
	)
	
	(print "Dot Rep Map")
	(if (equal (caddr currentmap) nil)
		(print "There is no dotrepmap")
		(printdotrepmap (caddr currentmap))
	)
	
	(print "Tile Rep Map")
	(if (equal (cadddr currentmap) nil)
		(print "There is no tilerepmap")
		(printtilerepmap (cadddr currentmap))
	)
	
	(print "Move List")
	(printmovelist (car (cddddr currentmap)))
	
	(print "Guess List")
	(loop for i from 0 to (- (list-length (cadr (cddddr currentmap))) 1) do
		(print (elt (cadr (cddddr currentmap)) i))
	)
)

;;-----------------------
(defun printlinerepmap (linerepmap)

	(loop for i from 0 to (- (list-length linerepmap) 1) do
		(print (elt linerepmap i))
	)
)

;;-----------------------
(defun printtilerepmap (tilerepmap)

	(loop for i from 0 to  (- (list-length tilerepmap) 1) do
		(print (elt tilerepmap i))
	)
)

;;-----------------------
(defun printdotrepmap (dotrepmap)

	(loop for i from 0 to  (- (list-length dotrepmap) 1) do
		(print (elt dotrepmap i))
	)
)

;;-----------------------
(defun makegameboard (mapname) 

	(setq aredotsvalid nil)
	(setq aretilesvalid nil)
	(setq isboardvalid nil)
	(Setq isaifucked nil)
	(cond 
		(	t
			(y-or-n-p "Would you like the AI to solve this map?") 
			(if (y-or-n-p "Will this be timed?") 
      			(cond
      				( t
      					(Setq istimed t) (Setq ishuman nil) (Setq printingwanted nil) (setq isAInotstuck nil)
      				)
      			)
      			(cond
      				(	(y-or-n-p "Would you like the map to be printed for every move?") 
						(setq istimed nil) (Setq ishuman nil) (Setq printingwanted t) (setq isAInotstuck nil)
					)
					( t
						(setq istimed nil) (Setq ishuman nil) (Setq printingwanted nil) (setq isAInotstuck nil)
					)
      			)
      		)
		)	
	)
	(setq originalmap 
		(list 
			mapname
			(makelinerepmap (list-length (eval mapname)) (list-length (car (eval mapname))))
		)
	)
	(setq originalmap  (append originalmap  (list (makedotrepmap (cadr originalmap ) (list-length (car (eval mapname)))))))
	(Setq originalmap  (append originalmap  (list (maketilerepmap  (caddr originalmap ) (eval mapname)))))
	(Setq originalmap  (append originalmap  (list nil) (list nil)))
	(setq gamemaps (list originalmap ))
	(string "The game map is now set. Enter (slither) to start the game.")
)


;;-----------------------

(defun slither ()
	(if ishuman
		(playhumangame)
		(if isTimed
			(playTimedAIGame)
			(playAIGame)
		)
	)
)

;;-----------------------
(defun playhumangame ()

	(loop
		(printstuff (car gamemaps))
	
		(progn 
			(format t "Make another move? y/n: ")
			(Setq answer (read))
		)
	
		(when 
			(cond
				(
					(equal answer 'y)
					(progn 
						(format t "Your next move is: ")
						(makemove (read) (read) (read))
					)
					(checkallvalidity (car gamemaps))
				)
				(t
					(return "Thanks for playing!")
				)
			)
		)

		(when isboardvalid 
			(if (playgameagain)
				(slither)
				(return "Thanks for playing!")
			)
			(return nil)
		)
	)
)


;;-----------------------
(defun playAIgame ()
	(setq countofstucks 0)
	(loop
		;;--------if they want the map printed at every point
		(if printingwanted
			(printstuff (car gamemaps))
			nil
		)
		
		;;--------validate all the things------
		(resetisAInotstuck)
		(doAllAI (car gamemaps))
		(checkallvalidity (car gamemaps))
		
		;;-----------if it is stuck, do something different
		(cond
			(isAInotstuck
				(setq countofstucks 0)
			)
			(t
				(cond
					((equal countofstucks 9)
					
						(if (not printingwanted)
							(printstuff (car gamemaps))
						)
						(return "The AI is stuck and the above solution is as far as it has solved. Sorry my AI isn't smarter.")
					)
					(
						t
						(setq countofstucks (+ 1 countofstucks))
					)
				)
			)
		)
		
		;;------ when the game is won ---------
		(when isboardvalid 
			(printstuff (car gamemaps))
			(if (playgameagain)
				(slither)
				(return "Thanks for playing!")
			)
			(return nil)
		)
	)
)

;;-----------------------
(defun playTimedAIGame()
	(setq countofstucks 0)
	(Setq timesfucked 0)
	(loop
		
		
		
		;;--------validate all the things------
		(resetisAInotstuck)
		(checkallvalidity (car gamemaps))
		
		(when isboardvalid 
			(printstuff (car gamemaps))
			(print "Board is valid")
			(return "Timing is now over")
		)
		
		
		(when isaifucked
			
			(erasemapswithnoguesses gamemaps)
			;;(printstuff (car gamemaps))
			(if (equal timesfucked 15)
				(and (printstuff (car gamemaps)) (return "AI fucked too much"))
				(setq timesfucked (+ 1 timesfucked))
			)
			
			(print "The AI is was fucked.")
			
			(dealwithbadguess (car gamemaps))
			(setq countofstucks 0)
			(setq isaifucked nil)
			
			
		;;	(return "Timing is now over")
		)
		
		(doAllAI (car gamemaps))
		
		;;------ when the game is won or AI is stuck ---------
		(cond
			(isAInotstuck
				(setq countofstucks 0)
			)
			((not isAInotstuck)
				(cond
					((equal countofstucks 10)	
						(printstuff (car gamemaps))
						(print "The AI is stuck and the above solution is as far as it has solved. Sorry my AI isn't smarter.")
						(return "Timing is now over")
					)
					(
						t
						(makeaguess (car gamemaps))
						(setq countofstucks (+ 1 countofstucks))
					)
				)
			)
		)
	)
)

;;------------------------


(defun erasemapswithnoguesses (gamemaplist)
	(setq maxbound (- (list-length gamemaplist) 1))
	(print maxbound)
	(loop for i from 0 to maxbound do
		(cond
			(
				(equal nil (cadr (cddddr (car gamemaplist))))
				(Setq gamemaps (cdr gamemaplist))
				(setq gamemaplist gamemaps)
			)
			(
				t
				(setq i maxbound)
			)
		)
	)
)

;;-----------------------
(defun makeaguess (currentmap)

	(deepcopycurrentgame currentmap)
	(setq linetoguesson (findintersectiontoguesswith (caddr (car gamemaps)) (cadr (cddddr (car gamemaps)))))
	(cond
		( 
			(equal linetoguesson nil)
			(setq isaifucked t)
		)
		(
			t
			(drawlineAI linetoguesson '"guess by the AI, so empty -> line." t currentmap)
		)
	)
)

;;-----------------------
(defun resetaguess (currentmap)
	
	(print "reset a guess")
	(deepcopycurrentgame currentmap)
	(setq linetoguesson (findlinewithrep (car gamemaps) (cadar (cadr (cddddr (cadr gamemaps))))))
	(banlineai linetoguesson '"guess by the AI went bad and reverted, so empty -> x." t currentmap)
	(print "end reset a guess")
)

;;-----------------------
(defun findlinewithrep (currentmap repthing)

	(print "find line with rep")
	(loop for i from 1 to (- (list-length (cadr currentmap) ) 2) do
		(setq thething (car (memember repthing (elt (cadr currentmap) i))))
		(if (not (equal thething nil))
			(setq i (- (list-length (cadr currentmap) ) 2))
		)
	)
	(print thething)
	(print "end fine line with rep")
	thething
)

;;-----------------------
(defun dealwithbadguess (currentmap)
	(print "deal with bad guess")
	(if 
		(equal 'line (caaar (cadr (cddddr (car gamemaps)))))
		(resetaguess currentmap)
		(revertbackanothermap)
	)
	
)

;;-----------------------
(defun dealwithbadguess2 (currentmap)
	(print "deal with bad guess 2")
	(if 
		(equal 'line (caaar (cadr (cddddr (car gamemaps)))))
		(resetaguess currentmap)
		(makeaguess currentmap)
	)
)

;;-----------------------
(defun revertbackanothermap ()
	(print "revert back another map")
	(setq gamemaps (cdr gamemaps))
	(dealwithbadguess2 (car gamemaps))
	
)

;;-----------------------
(defun addtoguesslist (currentmap linetoadd)

	(rplaca (cdr (cddddr currentmap)) (append (list linetoadd) (cadr (Cddddr currentmap))))
	
)


;;------------------------
(defun printstuff (currentmap)
	(printmap currentmap)
	(printmovelist (car (cddddr currentmap)))
	(printguesses)
	(dotstring)
	(tilestring)
	(statestring)
)

;;------------------------

(defun printmovelist (movelist)
	
	(loop for i from 0 to (- (list-length movelist) 1 ) do
		(print (elt movelist i))
	)
)

(defun printguesses ()
	
	(loop for j from 0 to (- (list-length gamemaps) 1) do
		(PRINT "map number")
		(print (- (list-length gamemaps) j))
		(loop for i from 0 to (- (list-length (cadr (cddddr (elt gamemaps j)))) 1 ) do
			(print (elt (cadr (cddddr (elt gamemaps j))) i))
		)
	)
)

;;------------------------

(defun playgameagain ()
  (if (y-or-n-p "You've won! Do you want to play another board?") 
      (progn (format t "Choose a map:~%~{~a, ~}" maplist)
             (makegameboard (read)) t)
             nil
	)
)


;;------------------------

(defun isinvalidrownumber (row)

	(and (> row 0) (<= row (list-length (eval (car currentmap)))))
)


;;------------------------

(defun isinvalidcolnumber (col)

	(and (> col 0) (<= col (list-length (car (eval (car currentmap))))))
)


;;------------------------

(defun isinvalidsideletter (side)

	(cond
		(
			(equal side 't)
			t
		)
		(
			(equal side 'b)
			t
		)
		(
			(equal side 'r)
			t
		)
		(
			(equal side 'l)
			t
		)
		(
			t
			nil
		)
	)
)

;;------------------------

(defun makemove (rownum colnum sidetoplaceline)
	
	(setq isMoveValid 
		(and 
			(isinvalidsideletter sidetoplaceline) 
			(isinvalidcolnumber colnum) 
			(isinvalidrownumber rownum)
		)
	)

	(if isMoveValid
		(setq lineinquestion (getplacementreference rownum colnum sidetoplaceline))
	)
	
	(if isMoveValid
		(cond
			( 
				(equal lineinquestion '(empty))
				(addtomovelist (list rownum colnum sidetoplaceline) 'line '"Human request")
				(rplaca lineinquestion 'line)
			)
			(
				t
				(print "Not a valid placement")
			)
		)
		(print "Bad input")
	)
)

;;------------------------

(defun linenum (currentmap)

	(ccount 'line (car (cddddr currentmap)))
	
)


;;------------------------

(defun checkallvalidity (currentmap)
	
	(setq validitychecks 
		(list 
			(checkdots (caddr currentmap)) 
			(checktiles (cadddr currentmap)) 
			;;(didanylinescauseclosedcircut currentmap ...)
			(isclosedcircut currentmap nil)
		)
	)
	
	(if
		(and (equal (member nil validitychecks) nil) (equal linecount (linenum currentmap)))
		(setq isboardvalid t)
	)	
	isboardvalid
)

;;------------------------

(defun doAllAI (currentmap)

	(tilesNumAI (cadddr currentmap) (caddr currentmap))
	(tilesAI (cadddr currentmap))
	(dotsAI (caddr currentmap))
)

;;------------------------
(defun tilesAI (tilerepmap)

	(loop for i from 1 to (list-length tilerepmap) do
		(mapcar #'tileAI (elt tilerepmap (- i 1)))
	)
)

;;------------------------
(defun getDotsForTile (tilerow tilecol dotrepmap)

	(list 
		(elt (elt dotrepmap (- tilerow 1)) (- tilecol 1))	;;top left dot
		(elt (elt dotrepmap (- tilerow 1)) tilecol)			;;top right dot
		(elt (elt dotrepmap tilerow) (- tilecol 1))			;;bottom left dot
		(elt (elt dotrepmap tilerow) tilecol)				;;bottom right dot
	)
)

;;------------------------
(defun tilesNumAI (tilerepmap dotrepmap)

	(loop for i from 1 to (list-length tilerepmap) do
		(loop for j from 1 to (list-length (elt tilerepmap (- i 1))) do
		 	(tileNumAI (elt (elt tilerepmap (- i 1)) (- j 1)) dotrepmap)
		)
	)
)

;;------------------------
(defun tileNumAI (tile dotrepmap)

	(if (equal (car tile) '@)
		(setq numberintile -1)
		(setq numberintile (car tile))
	)
	
	(setq countoflines (ccount '(line) tile))
	(setq countofxs ( + (ccount '(xx) tile) (ccount '(x) tile)))
	(setq countofemptys (ccount '(empty) tile))
	
	(cond
		( 
			(and (equal numberintile 3) (> 3 countoflines))
			(setq dotsfortile (getdotsfortile (Car (Cadr (cadr tile))) (Cadr (cadr (cadr tile))) dotrepmap))
			
			(topleftcornercheckAI (car dotsfortile) tile)
			(toprightcornercheckAI (cadr dotsfortile) tile)
			(bottomleftcornercheckAI (caddr dotsfortile) tile)
			(bottomrightcornercheckAI (cadddr dotsfortile) tile)

		)
	)
)

;;------------------------
(defun topleftcornercheckAI  (dot tile)
	
	(setq countoflines (ccount '(line) tile))
	(setq countofxs ( + (ccount '(xx) tile) (ccount '(x) tile)))
	(setq countofemptys (ccount '(empty) tile))

	(cond
		(
			(and (or (equal (caar dot) '(x)) (equal (caar dot) '(xx))) (or (equal (Car (cadddr dot)) '(x)) (equal (car (cadddr dot)) '(xx))))
		
			(Setq changing (cadr tile))
			(cond
				(
					(equal (car changing) '(empty))
					(drawlineAI changing '"top left corner on a 3 tile, so empty -> line." nil nil)
				)
				(
					t
					(isAInotstuck nil)
				)
			)
			
			(Setq changing (car (cddddr tile)))
			(cond
				(
					(equal (car changing) '(empty))
					(drawlineAI changing '"top left corner on a 3 tile, so empty -> line." nil nil)
				)
				(
					t
					(isAInotstuck nil)
				)
			)	
		)
	)
)

;;------------------------
(defun toprightcornercheckAI (dot tile)

	(setq countoflines (ccount '(line) tile))
	(setq countofxs ( + (ccount '(xx) tile) (ccount '(x) tile)))
	(setq countofemptys (ccount '(empty) tile))

	(cond
		(
			(and (or (equal (caar dot) '(x)) (equal (caar dot) '(xx))) (or (equal (Car (cadr dot)) '(x)) (equal (car (cadr dot)) '(xx))))
		
			(Setq changing (cadr tile))
			(cond
				(
					(equal (car changing) '(empty))
					(drawlineAI changing '"top right corner on a 3 tile, so empty -> line." nil nil)
				)
				(
					t
					(isAInotstuck nil)
				)
			)
			
			(Setq changing (car (cdr tile)))
			(cond
				(
					(equal (car changing) '(empty))
					(drawlineAI changing '"top right corner on a 3 tile, so empty -> line." nil nil)
				)
				(
					t
					(isAInotstuck nil)
				)
			)	
		)
	)
)

;;------------------------
(defun bottomleftcornercheckAI (dot tile)

	(setq countoflines (ccount '(line) tile))
	(setq countofxs ( + (ccount '(xx) tile) (ccount '(x) tile)))
	(setq countofemptys (ccount '(empty) tile))

	(cond
		(
			(and (or (equal (caaddr dot) '(x)) (equal (caaddr dot) '(xx))) (or (equal (Car (cadddr dot)) '(x)) (equal (car (cadddr dot)) '(xx))))
		
			(Setq changing (cadddr tile))
			(cond
				(
					(equal (car changing) '(empty))
					(drawlineAI changing '"bottom left corner on a 3 tile, so empty -> line." nil nil)
				)
				(
					t
					(isAInotstuck nil)
				)
			)
			
			(Setq changing (car (cddddr tile)))
			(cond
				(
					(equal (car changing) '(empty))
					(drawlineAI changing '"bottom left corner on a 3 tile, so empty -> line." nil nil)
				)
				(
					t
					(isAInotstuck nil)
				)
			)	
		)
	)
)

;;------------------------
(defun bottomrightcornercheckAI (dot tile)

	(setq countoflines (ccount '(line) tile))
	(setq countofxs ( + (ccount '(xx) tile) (ccount '(x) tile)))
	(setq countofemptys (ccount '(empty) tile))

	(cond
		(
			(and (or (equal (caadr dot) '(x)) (equal (caadr dot) '(xx))) (or (equal (Car (caddr dot)) '(x)) (equal (car (caddr dot)) '(xx))))
		
			(Setq changing (caddr tile))
			(cond
				(
					(equal (car changing) '(empty))
					(drawlineAI changing '"bottom right corner on a 3 tile, so empty -> line." nil nil)
				)
				(
					t
					(isAInotstuck nil)
				)
			)
			
			(Setq changing (car (cdddr tile)))
			(cond
				(
					(equal (car changing) '(empty))
					(drawlineAI changing '"bottom right corner on a 3 tile, so empty -> line." nil nil)
				)
				(
					t
					(isAInotstuck nil)
				)
			)	
		)
	)
)


;;------------------------
(defun dotsAI (dotrepmap)

	(loop for i from 1 to (list-length dotrepmap) do
		(mapcar #'dotAI (elt dotrepmap (- i 1)))
	)
)

;;------------------------

(defun checkdots (dotrepmap)

	(resetaredotsvalid)	
			
	(loop for i from 1 to (list-length dotrepmap) do
		(mapcar #'checkdot (elt dotrepmap (- i 1)))
	)
			
	aredotsvalid
)


;;------------------------

(defun checktiles (tilerepmap)

	(resetaretilesvalid)

	(loop for i from 1 to (list-length tilerepmap) do
		(mapcar #'checktile (elt tilerepmap (- i 1)))
	)

	aretilesvalid
)


;;------------------------
(defun resetaredotsvalid ()

	(setq aredotsvalid t)

)

;;------------------------
(defun aredotsvalid (isitthough)

	(setq aredotsvalid (and isitthough aredotsvalid))

)

;;------------------------
(defun resetaretilesvalid ()

	(setq aretilesvalid t)

)
;;------------------------
(defun aretilesvalid (isitthough)

	(setq aretilesvalid (and isitthough aretilesvalid))

)

;;------------------------
(defun ccount (thingtocount thingtocounton)
	
	(Setq total 0)
	(loop for i from 0 to (- (list-length thingtocounton) 1)  do
		(if (listp (elt thingtocounton i))
		(Setq total (+ total (count thingtocount (elt thingtocounton i) :test #'equal)))
		)
	)
	total
)

;;------------------------
(defun mmember (thingtomember thingtomemberon)
	
	(Setq result nil)
	(loop for i from 0 to (- (list-length thingtomemberon) 1)  do
		(cond
			(	
				(listp (elt thingtomemberon i))
				(Setq result (member thingtomember (elt thingtomemberon i) :test #'equal))
				(if (not (equal result '() ) )
					(setq i (list-length thingtomemberon))
			
				)
			)
		)
	)
	result
)

;;------------------------
(defun dotAI ( dottocheck )

	(setq countoflines (ccount '(line) dottocheck))
	(setq countofxs ( + (ccount '(xx) dottocheck) (ccount '(x) dottocheck)))
	(setq countofemptys (ccount '(empty) dottocheck))

	(cond	
		(
			(and (equal countofxs 3) (equal 1 countofemptys))
			(Setq changing (mmember '(empty) dottocheck))
			(banlineai changing '"count of x's was 3 in intersection, so empty -> x." nil nil)
		)
		(
			(and (equal countoflines 2) (> countofemptys 0) )

			(loop for i from 1 to countofemptys do 
				(setq changing (mmember '(empty) dottocheck))
				(banlineai changing '"count of lines in intersection was 2, so empty -> x." nil nil)
				(isAInotstuck t)
			)

		)
		(
			(equal countofxs 2)
			(cond 
				( 
					(equal countoflines 1)
					(Setq changing (mmember '(empty) dottocheck))
					(drawlineAI changing '"count of x's was 2 and line was 1 in intersection, so empty -> line." nil nil)
				)
			)
		)
		(t
			(isAInotstuck nil)
		)
	)
)

;;------------------------
(defun checkdot ( dottocheck )

	(setq countoflines (ccount '(line) dottocheck))
	(setq countofxs ( + (ccount '(xx) dottocheck) (ccount '(x) dottocheck)))
	(setq countofemptys (ccount '(empty) dottocheck))

	(cond
		(
			(equal countoflines 4)
			(print "Bad dot")
			(print dottocheck) 
			(setq isaifucked t)
			(aredotsvalid nil)
		)
		(
			(equal countoflines 3) 
			(print "Bad dot")
			(print dottocheck) 
			(Setq isaifucked t)
			(aredotsvalid nil)
		)
		(
			(equal countoflines 2)
			(aredotsvalid t)
		)
		(
			(equal countoflines 1)
			(if (equal countofxs 3)
				(Setq isaifucked t)
			)
			(aredotsvalid nil)
		)
		(
			t
			(aredotsvalid t)
		)
	)
)

;;------------------------
(defun isAInotstuck (value)

	(setq isAInotstuck (or value isAInotstuck))
)

;;------------------------

(defun resetisAInotstuck ()

(setq isAInotstuck nil)

)

;;------------------------

(defun addtomovelist (placeyouchanged whatyouchangedto whyyouchangedit)

	(rplaca (cddddr (Car gamemaps)) (append (car (cddddr (car gamemaps))) (list (list placeyouchanged whatyouchangedto whyyouchangedit))))

)

;;------------------------

(defun tileAI ( tiletocheck )

	(if (equal (car tiletocheck) '@)
		(setq numberintile -1)
		(setq numberintile (car tiletocheck))
	)
	
	(setq countoflines (ccount '(line) tiletocheck))
	(setq countofxs ( + (ccount '(xx) tiletocheck) (ccount '(x) tiletocheck)))
	(setq countofemptys (ccount '(empty) tiletocheck))
	
	(cond
		(	
			(equal numberintile -1)
			(isAInotstuck nil)
		)
		( 
			(equal countoflines numberintile) 
			(cond 
				( 
					(> countofemptys 0) 
					(loop for i from 1 to countofemptys do 
						(Setq changing (mmember '(empty) tiletocheck ))
						(banlineai changing '"count of lines was equal to number in tile, so empty -> x." nil nil)
					)
				)
				(	t
					(isAInotstuck nil)
				)
			)	
		)
		(
			t
			(cond 
				(	
					(and (> countofemptys 0) (equal countofxs (- 4 numberintile)))
					(loop for i from 1 to countofemptys do 
						(Setq changing (mmember '(empty) tiletocheck))
						(drawlineai changing '"count of x's was equal to 4 - number in tile, so empty -> line." nil nil)
					)
				)
				(	t
					(isAInotstuck nil)
				)
			)			
		)
		(	
			t
			(isAInotstuck nil)
		)
	)	
)

;;------------------------
(defun checktile ( tiletocheck )

	(if (equal (car tiletocheck) '@)
		(setq numberintile -1)
		(setq numberintile (car tiletocheck))
	)
	
	(setq countoflines (ccount '(line) tiletocheck))
	(setq countofxs ( + (ccount '(xx) tiletocheck) (ccount '(x) tiletocheck)))
	(setq countofemptys (ccount '(empty) tiletocheck))
	
	(cond
		( (equal numberintile -1)
			(aretilesvalid t)
		)
		(
			(equal countoflines numberintile) 
			;;GOOD
			;;is some empty spots
			;;set all the other lines to x's
			(aretilesvalid t)
		)
		(
			(< countoflines numberintile) 
			;;can be good or bad or ugly
			
			(cond
				((equal countofemptys (- numberintile countoflines))
					;;GOOD
					;;is some empty spots
					;;set all the other lines to x's
					(aretilesvalid nil)
				)
				((> countofemptys 0)
					;;fine
					;;(print tiletocheck)
					(aretilesvalid nil)
				)
				(t
					;;if all others are x's
					;;BAD
					;;which could happen because corners or something
					;;bad juju
					(print "Bad tile")
					(print tiletocheck)
					(setq isaifucked t)
					(aretilesvalid nil)
				)
			)
		)
		(
			t
			;;BAD
			;;CANNOT HELP
			;;BAD BAD BAD
			(print "Bad tile")
			(print tiletocheck)
			(setq isaifucked t)
			(aretilesvalid nil)
		)
	)	
	aretilesvalid
)

;;------------------------

(defun getplacementreference( rownum colnum sidetoplaceline ) 

		(setq rownum (convertcontenttolinerow rownum))
		
	
		(cond
			(
				(equal sidetoplaceline 'T)
				(setq rownum (- rownum 1))
			)
			(
				(equal sidetoplaceline 'B)
				(setq rownum (+ rownum 1))
			)		
		)
	
		(cond
			(
				(equal sidetoplaceline 'R)
				(setq  colnum (+ colnum 1))
			)
			(
				(equal sidetoplaceline 'T)
				(setq colnum (+ colnum 1))
			)
			(
				(equal sidetoplaceline 'B)
				(setq colnum (+ colnum 1))
			)	
		)
	
		(elt (elt linerepmap (- rownum 1)) (- colnum 1))

)


;;------------------------
;;assuming that the dots and tiles are all valid before calling this

(defun isclosedcircut (currentmap linetostart)

	(setq foundclosedcircut nil)
	(cond
		(
			(< (linenum currentmap) 4)
			(setq isboardvalid nil)
		)
		(t
			(if (equal nil linetostart)
				(findfirstline (cadr currentmap))
				(setq firstline linetostart)
			)		;;firstline will now be set with some line
			(Setq linecount 0)
			(Setq nextline nil)
			(setq currentline nil)
			(findnextline currentmap)
			(setq isboardvalid (equal linecount (linenum currentmap)))
			
		)
	)	
	
	foundclosedcircut
)


;;------------------------
(defun findfirstline (linerepmap)

	(setq firstline nil)

	(loop for i from 2 to (- (list-length linerepmap) 1) do
		(loop for j from 1 to (list-length (elt linerepmap (- i 1))) do
			(cond
				(
					(equal (car (elt (elt linerepmap (- i 1)) (- j 1)) ) '(line))
					(setq firstline (list (eval i) (eval j)))
					(Setq j (list-length (elt linerepmap (- i 1))))
					(setq i (- (list-length linerepmap) 1))
				)
			)
		)
		
	)
	firstline
)

;;------------------------
(defun findnextline (currentmap)

	(cond
		(
			(equal linecount 0)
			(setq currentline firstline)
			(setq nextline (car (findlinenexttoyou currentline nil currentmap)))
			
			(setq linecount (+ 1 linecount))
			(findnextline currentmap)
		)
		(	
			(equal firstline nextline)
			(setq foundclosedcircut t)
		)
		(t
			(setq templine (car (findlinenexttoyou nextline currentline currentmap)))
			(setq currentline nextline)
			(setq nextline templine)
			(cond
				(
					(equal nextline nil)
					(setq foundclosedcircut nil)
				)
				(
					t
					(setq linecount (+ 1 linecount))
					(findnextline currentmap)
				)
			)
		)
	)
	linecount	
)

;;------------------------
(defun findlinenexttoyou (lineyouare linetoomit currentmap)

	(if
		(equal (mod (Car lineyouare) 2) 0)
		(Setq linestoreturn
			(findlinenexttoyoueven lineyouare currentmap)
		)
		(setq linestoreturn 
			(findlinenexttoyouodd lineyouare currentmap)
		)
	)
	(setq linestoreturn (remove linetoomit linestoreturn :test #'equal))
)

;;------------------------
(defun findlinenexttoyouodd (lineyouare currentmap)

	(setq listtoreturn '())
	
	
	(if
		(returnifline (- (car lineyouare) 1) (cadr lineyouare) currentmap)
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(- (car lineyouare) 1) 
					(cadr lineyouare)
				))
			)
		)
	)
	(if
		(returnifline (+ (car lineyouare) 1) (cadr lineyouare) currentmap)
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(+ (car lineyouare) 1) 
					(cadr lineyouare)
				))
			)
		)
	)
	(if
		(returnifline (- (car lineyouare) 1) (+ 1 (cadr lineyouare)) currentmap)
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(- (car lineyouare) 1) 
					(+ 1 (cadr lineyouare))
				))
			)
		)
	)
	(if
		(returnifline (+ (car lineyouare) 1) (+ 1 (cadr lineyouare)) currentmap)
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(+ (car lineyouare) 1) 
					(+ 1 (cadr lineyouare))
				))
			)
		)
	)
	(if
		(returnifline (+ (car lineyouare) 2) (cadr lineyouare) currentmap)
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(+ (car lineyouare) 2) 
					(cadr lineyouare)
				))
			)
		)
	)
	(if
		(returnifline (- (car lineyouare) 2) (cadr lineyouare) currentmap)
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(- (car lineyouare) 2) 
					(cadr lineyouare)
				))
			)
		)
	)
	listtoreturn
)

;;------------------------
(defun findlinenexttoyoueven (lineyouare currentmap)

	(setq listtoreturn '())
	
	
	(if
		(returnifline (- (car lineyouare) 1) (cadr lineyouare) currentmap)
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(- (car lineyouare) 1) 
					(cadr lineyouare)
				))
			)
		)
	)
	(if
		(returnifline (+ (car lineyouare) 1) (cadr lineyouare) currentmap)
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(+ (car lineyouare) 1) 
					(cadr lineyouare)
				))
			)
		)
	)
	(if
		(returnifline (- (car lineyouare) 1) (- (cadr lineyouare) 1) currentmap)
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(- (car lineyouare) 1)
					(- (cadr lineyouare) 1)
				))
			)
		)
	)
	(if
		(returnifline (+ (car lineyouare) 1) (- (cadr lineyouare) 1) currentmap)
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(+ (car lineyouare) 1) 
					(- (cadr lineyouare) 1)
				))
			)
		)
	)
	(if
		(returnifline (car lineyouare) (- (cadr lineyouare) 1) currentmap)
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(car lineyouare) 
					(- (cadr lineyouare) 1)
				))
			)
		)
	)
	(if
		(returnifline (car lineyouare) (+ (cadr lineyouare) 1) currentmap)
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(car lineyouare) 
					(+ (cadr lineyouare) 1)
				))
			)
		)
	)
	listtoreturn
)

;;------------------------
(defun returnifline (rownumber columnnumber currentmap)

	(equal (car (elt (elt (cadr currentmap) (- rownumber 1)) (- columnnumber 1))) '(line))
)

;;------------------------
(defun statestring ()
	(cond
		( isboardvalid 
			(print "Game is over and the board is correct.")
			maplist
		)
		( t
			(print "Board is still incorrect or not completed.")
		)
	)
)
;;------------------------
(defun dotstring ()
	(if aredotsvalid 
		(print "Intersections are valid")
		(print "Some intersections are not valid")
	)
)
;;------------------------
(defun tilestring ()
	(if aretilesvalid 
		(print "Tiles are valid")
		(print "Some tiles are not valid")
	)
)


;;------------------------

(defun convertlinetocontentrow (number)
	(/ (- number 1) 2 )
)

;;------------------------

(defun convertcontenttolinerow (number)
	(+ (* number 2) 1 )
)


;;------------------------
(defun makemap (mapname mapcontents)

	 (set mapname mapcontents)
	 (setq maplist (append maplist (list mapname)))
 )


;;------------------------
(defun makelinerepmap (rownum colnum)

	(loop for i from 1 to (+ (* rownum 2) 3) collect
		(cond 
			((or (equal 1 i) (equal (+ (* rownum 2) 3) i))
				(make-sequence 'list (+ 1 colnum) :initial-element '((xx)))
			)
			((equal (mod i 2) 0)
				(if (> (/ i 2) rownum)
					(middleRowBottomLineRepMpa i colnum)
					(middleRowNotBottomLineRepMpa i colnum)
				)
			)
			(t 
				(append 
					(loop for j from 0 to (- colnum 1) collect 
						(list (list 'empty) (list (/ (- i 1) 2) (+ j 1) 'L))
					)
					(list (list (list 'empty) (list (/ (- i 1) 2) colnum 'R)))
				)
			)
		)
	)
)

;;------------------------
(defun middleRowNotBottomLineRepMpa(rrownum colnum)

	(append 
		(list '((xx))) 
		(loop for j from 1 to colnum collect
		(list (list 'empty) (list (/ rrownum 2) j 'T)))
		(list '((xx)))
	)
)

;;------------------------
(defun middleRowBottomLineRepMpa(rrownum colnum)

	(append 
		(list '((xx)))
		(loop for j from 1 to colnum collect
		(list (list 'empty) (list (- (/ rrownum 2) 1) j 'B)))
		(list '((xx)))
	)
)

;;------------------------
(defun createdot (numberrow numbercol linerepmap)		
	(list 
		(elt (elt linerepmap (- numberrow 1)) (- numbercol 1))
	
		(elt (elt linerepmap numberrow) numbercol)
	
		(elt (elt linerepmap (+ numberrow 1)) (- numbercol 1))
	
		(elt (elt linerepmap numberrow) (- numbercol 1))
	)
)

;;------------------------
(defun makedotrepmap (linerepmap colnum)

	(remove nil
		(setq listofdots
			(loop for i from 1 to (- (list-length linerepmap) 1) collect
				
				(cond
						((equal (equal (mod i 2) 0) NIL)
						(loop for j from 1 to (+ 1 colnum) collect
							(createdot i j linerepmap))
						)
				)
			)
		)
	)
)



;;------------------------
(defun maketilerepmap (dotrepmap mapcontents)
 
	(loop for i from 1 to (list-length mapcontents) collect
		(loop for j from 1 to (list-length (car mapcontents)) collect
			(list (elt (elt mapcontents (- i 1)) (- j 1))
			(elt (elt (elt dotrepmap (- i 1)) (- j 1)) 1)
			(elt (elt (elt dotrepmap i) j) 0)
			(elt (elt (elt dotrepmap i) j) 3)
			(elt (elt (elt dotrepmap (- i 1)) (- j 1)) 2)
			)
		)	
	)
)


;;------------------------

(defun getprintmap (currentmap)

	(setq columnnumbered nil)

		(loop for j from 0 to (- (list-length (car (cadr currentmap))) 1) do
			(Setq columnnumbered (append columnnumbered (list j '-)))
		)
	
	(setq result
		(loop for i from 2 to (- (list-length (cadr currentmap)) 1) collect
			(cond
				((equal 0 (mod i 2))
				 	(append (list '-)(printevenrow i (cadr currentmap)))
				)
				(t
					(append (list (/ (- i 1) 2))(printoddrow i (cadr currentmap) (car currentmap)))
				)
			)
		)
	)
	
	(setq resultresult (append (list columnnumbered) result))
)

;;------------------------

(defun convertsymboleven (symbol)

	(cond
		((equal '(line) (car symbol))
			'=
		)(t 
			(convertsymbolany symbol)
		)
	)
)

;;------------------------

(defun convertsymbolodd (symbol)

	(cond 
		((equal '(line) (car symbol))
			'i
		)
		(t 
			(convertsymbolany symbol)
		)
	)
)

;;------------------------

(defun convertsymbolany (symbol)
	
	(cond 
		((equal '(xx) symbol) 
			'x
		)
		((equal '(x) (car symbol))
			'x
		)
		((equal '(empty) (car symbol))
			'*
		)
	)
)

;;------------------------

(defun printevenrow (rowtoprint linerepmap)
	(setq lines (mapcar #'convertsymboleven (elt linerepmap (- rowtoprint 1))
	))
	 
	(setq result '())
	
	(loop for i from 1 to (- (list-length lines) 2) do
		(setq result 
			(append result 
				(list 
					'+
					(elt lines i)
				)
			)
		)
	)
	
	(append result (list '+))
)

;;------------------------

(defun printoddrow (rowtoprint linerepmap mapname)
	(setq symbols 
		(mapcar #'convertsymbolodd 
			(elt linerepmap (- rowtoprint 1)
			)
		)
	)
	
	(setq mapcontentsrow (elt (eval mapname) (- (convertlinetocontentrow rowtoprint) 1 )))
	
	(setq result '())
	
	(loop for i from 1 to (list-length mapcontentsrow) do
		(setq result 
			(append result 
				(list 
					(elt symbols (- i 1))
					(elt mapcontentsrow (- i 1))
				)
			)
		)
	)
	
	(append result (last symbols 1))
)


;;------------------------

(defun printmap (currentmap)

	(setq resultresult (getprintmap currentmap))
	
	
	(loop for i from 0 to (- (list-length resultresult) 1 ) do
		(print (elt resultresult i))
	)
)

;;------------------------