(defun slither ()
	(if ishuman
		(playhumangame)
		(playAIgame)
	)
)

;;-----------------------
(defun playhumangame ()

	(loop
		(printstuff)
	
		(progn 
			(format t "Make another move? y/n: ")
			(Setq answer (read))
		)
	
		(when 
			(cond
				(
					(equal answer 'y)
					(progn 
						(format t "Your next move is: ")
						(makemove (read) (read) (read))
					)
					(checkallvalidity)
				)
				(t
					(return "Thanks for playing!")
				)
			)
		)

		(when isboardvalid 
			(if (playgameagain)
				(slither)
				(return "Thanks for playing!")
			)
			(return nil)
		)
	)
)


;;-----------------------
(defun playAIgame ()

	(loop
		;;--------if they want the map printed at every point
		(if printingwanted
			(printstuff)
			nil
		)
		
		;;--------validate all the things------
		(resetisAInotstuck)
		(doAllAI)
		(checkallvalidity)
		
		;;-----------if it is stuck, do something different
		(cond
			(isAInotstuck
				
			)
			(t
				(if (not printingwanted)
					(printstuff)
				)
				(return "The AI is stuck and the above solution is as far as it has solved. Sorry my AI isn't smarter.")
			)
		)
		
		;;------ when the game is won ---------
		(when isboardvalid 
			(printstuff)
			(if (playgameagain)
				(slither)
				(return "Thanks for playing!")
			)
			(return nil)
		)
	)
)

;;------------------------

(defun printstuff ()
	(printmap)
	(printmovelist)
	(dotstring)
	(tilestring)
	(statestring)
)

;;------------------------

(defun printmovelist ()
	
	(loop for i from 0 to (- (list-length movelist) 1 ) do
		(print (elt movelist i))
	)
)

;;------------------------

(defun playgameagain ()
  (if (y-or-n-p "You've won! Do you want to play another board?") 
      (progn (format t "Choose a map:~%~{~a, ~}" maplist)
             (makegameboard (read)) t)
             nil
	)
)


;;------------------------

(defun isinvalidrownumber (row)

	(and (> row 0) (<= row (list-length (eval (car currentmap)))))
)


;;------------------------

(defun isinvalidcolnumber (col)

	(and (> col 0) (<= col (list-length (car (eval (car currentmap))))))
)


;;------------------------

(defun isinvalidsideletter (side)

	(cond
		(
			(equal side 't)
			t
		)
		(
			(equal side 'b)
			t
		)
		(
			(equal side 'r)
			t
		)
		(
			(equal side 'l)
			t
		)
		(
			t
			nil
		)
	)
)

;;------------------------

(defun makemove (rownum colnum sidetoplaceline)
	
	(setq thingy 
		(and 
			(isinvalidsideletter sidetoplaceline) 
			(isinvalidcolnumber colnum) 
			(isinvalidrownumber rownum)
		)
	)

	(if thingy
		(setq lineinquestion (getplacementreference rownum colnum sidetoplaceline))
	)
	
	(if thingy
		(cond
			( 
				(equal lineinquestion '(empty))
				(lineadded)
				(addtomovelist (list rownum colnum sidetoplaceline) 'line '"Human request")
				(rplaca lineinquestion 'line)
			)
			(
				t
				(print "Not a valid placement")
			)
		)
		(print "Bad input")
	)
)

;;------------------------

(defun lineadded ()

	(setq linenum (+ 1 linenum))

)


;;------------------------

(defun checkallvalidity ()
	
	(setq validitychecks (list (checkdots dotrepmap) (checktiles tilerepmap)))
	(if
		(equal (member nil validitychecks) nil)
		(isclosedcircut)
	)	
	isboardvalid
)

;;------------------------

(defun doAllAI ()

	(tilesAI tilerepmap)
	(dotsAI dotrepmap)

)

;;------------------------
(defun tilesAI (tilerepmap)

	(loop for i from 1 to (list-length tilerepmap) do
		(mapcar #'tileAI (elt tilerepmap (- i 1)))
	)
)

;;------------------------
(defun dotsAI (dotrepmap)

	(loop for i from 1 to (list-length dotrepmap) do
		(mapcar #'dotAI (elt dotrepmap (- i 1)))
	)
)

;;------------------------

(defun checkdots (dotrepmap)

	(resetaredotsvalid)	
			
	(loop for i from 1 to (list-length dotrepmap) do
		(mapcar #'checkdot (elt dotrepmap (- i 1)))
	)
			
	aredotsvalid
)


;;------------------------

(defun checktiles (tilerepmap)

	(resetaretilesvalid)

	(loop for i from 1 to (list-length tilerepmap) do
		(mapcar #'checktile (elt tilerepmap (- i 1)))

	)

	aretilesvalid
)


;;------------------------
(defun resetaredotsvalid ()

(setq aredotsvalid t)

)

;;------------------------
(defun aredotsvalid ( isitthough)

(setq aredotsvalid (and isitthough aredotsvalid))

)

;;------------------------
(defun resetaretilesvalid ()

(setq aretilesvalid t)

)
;;------------------------
(defun aretilesvalid ( isitthough)

(setq aretilesvalid (and isitthough aretilesvalid))

)

;;------------------------
(defun ccount (thingtocount thingtocounton)
	
	(Setq total 0)
	(loop for i from 0 to (- (list-length thingtocounton) 1)  do
		(if (listp (elt thingtocounton i))
		(Setq total (+ total (count thingtocount (elt thingtocounton i) :test #'equal)))
		)
	)
	total
)

;;------------------------
(defun mmember (thingtomember thingtomemberon)
	
	(Setq result nil)
	(loop for i from 0 to (- (list-length thingtomemberon) 1)  do
		(cond
			(	
				(listp (elt thingtomemberon i))
				(Setq result (member thingtomember (elt thingtomemberon i) :test #'equal))
				(if (not (equal result '() ) )
					(setq i (list-length thingtomemberon))
			
				)
			)
		)
	)
	result
)

;;------------------------
(defun dotAI ( dottocheck )

	(setq countoflines (ccount '(line) dottocheck))
	(setq countofxs ( + (ccount '(xx) dottocheck) (ccount '(x) dottocheck)))
	(setq countofemptys (ccount '(empty) dottocheck))

	(cond	
		(
			(equal countofxs 3)
			(Setq changing (mmember '(empty) dottocheck))
			(rplaca (car changing) 'x)
			(addtomovelist (cadr changing) 'x '"count of x's was 3 in intersection, so empty -> x.")
			(isAInotstuck t)
		)
		(
			(and (equal countoflines 2) (> countofemptys 0) )

			(loop for i from 1 to countofemptys do 
				(setq changing (mmember '(empty) dottocheck))
				(rplaca (car changing) 'x)
				(addtomovelist (Cadr changing) 'x '"count of lines in intersection was 2, so empty -> x.")
			)
						
			(isAInotstuck t)

		)
		(
			(equal countofxs 2)
			(cond ( (equal countoflines 1)
				(Setq changing (mmember '(empty) dottocheck))
				(rplaca (car changing) 'line)
				(lineadded)
				(addtomovelist (cadr changing) 'line '"count of x's was 2 and line was 1 in intersection, so empty -> line.")
				(isAInotstuck t)
				)
			)
		)
		(t
		(isAInotstuck nil)
		)
	)
)

;;------------------------
;;THIS NEEDS TO BE CHANGED
(defun checkdot ( dottocheck )

	(setq countoflines (ccount '(line) dottocheck))
	(setq countofxs ( + (ccount '(xx) dottocheck) (ccount '(x) dottocheck)))
	(setq countofemptys (ccount '(empty) dottocheck))

	(cond
		(
			(equal countoflines 4) 
			;;(setq isaifucked t)
			(aredotsvalid nil)
		)
		(
			(equal countoflines 3) 
			;;(Setq isaifucked t)
			(aredotsvalid nil)
		)
		(
			(equal countoflines 2)
			(aredotsvalid t)
		)
		(
			(equal countoflines 1)
			(aredotsvalid nil)
		)
		(
			t
			(aredotsvalid t)
		)
	)
)

;;------------------------
(defun isAInotstuck (value)

	(setq isAInotstuck (or value isAInotstuck))
)

;;------------------------

(defun resetisAInotstuck ()

(setq isAInotstuck nil)

)

;;------------------------

(defun addtomovelist ( placeyouchanged whatyouchangedto whyyouchangedit)

	(Setq movelist (append movelist (list (list placeyouchanged whatyouchangedto whyyouchangedit))))

)

;;------------------------
;;THIS NEEDS TO BE CHANGED ;;I AM HERE

(defun tileAI ( tiletocheck )

	(if (equal (car tiletocheck) '@)
		(setq numberintile -1)
		(setq numberintile (car tiletocheck))
	)
	
	(setq countoflines (ccount '(line) tiletocheck))
	(setq countofxs ( + (ccount '(xx) tiletocheck) (ccount '(x) tiletocheck)))
	(setq countofemptys (ccount '(empty) tiletocheck))
	
	(cond
		(	
			(equal numberintile -1)
			(isAInotstuck nil)
		)
		( 
			(equal countoflines numberintile) 
			(cond 
				( 
					(> countofemptys 0) 
					(loop for i from 1 to countofemptys do 
						(Setq changing (mmember '(empty) tiletocheck ))
						(rplaca (Car changing) 'x)
						(addtomovelist (cadr changing) 'x '"count of lines was equal to number in tile, so empty -> x.")
					)
					(isAInotstuck t)
				)
				(	t
					(isAInotstuck nil)
				)
			)	
		)
		(
			t
				(cond 
					(	
						(and (> countofemptys 0) (equal countofxs (- 4 numberintile)))
						(loop for i from 1 to countofemptys do 
							(Setq changing (mmember '(empty) tiletocheck))
							(rplaca (Car changing) 'line)
							(lineadded)
							(addtomovelist (cadr changing) 'line '"count of x's was equal to 4 - number in tile, so empty -> line.")
						)
						(isAInotstuck t)
					)
					(	t
						(isAInotstuck nil)
					)
				)
						
		)
		(	
			t
			(isAInotstuck nil)
		)
	)	
)

;;------------------------
(defun checktile ( tiletocheck )

	(if (equal (car tiletocheck) '@)
		(setq numberintile -1)
		(setq numberintile (car tiletocheck))
	)
	
	(setq countoflines (ccount '(line) tiletocheck))
	(setq countofxs ( + (ccount '(xx) tiletocheck) (ccount '(x) tiletocheck)))
	(setq countofemptys (ccount '(empty) tiletocheck))
	
	(cond
		( (equal numberintile -1)
			(aretilesvalid t)
		)
		(
			(equal countoflines numberintile) 
			;;GOOD
			;;is some empty spots
			;;set all the other lines to x's
			(aretilesvalid t)
		)
		(
			(< countoflines numberintile) 
			;;can be good or bad or ugly
			
			(cond
				((equal countofemptys (- numberintile countoflines))
					;;GOOD
					;;is some empty spots
					;;set all the other lines to x's
					(aretilesvalid nil)
				)
				((> countofemptys 0)
					;;fine
					;;(print tiletocheck)
					(aretilesvalid nil)
				)
				(t
					;;if all others are x's
					;;BAD
					;;which could happen because corners or something
					;;bad juju
					;;(print tiletocheck)
					(aretilesvalid nil)
				)
			)
		)
		(
			t
			;;BAD
			;;CANNOT HELP
			;;BAD BAD BAD
			;;(print tiletocheck)
			(aretilesvalid nil)
		)
	)	
	aretilesvalid
)

;;------------------------

(defun getplacementreference( rownum colnum sidetoplaceline ) 

		(setq rownum (convertcontenttolinerow rownum))
		
	
		(cond
			(
				(equal sidetoplaceline 'T)
				(setq rownum (- rownum 1))
			)
			(
				(equal sidetoplaceline 'B)
				(setq rownum (+ rownum 1))
			)		
		)
	
		(cond
			(
				(equal sidetoplaceline 'R)
				(setq  colnum (+ colnum 1))
			)
			(
				(equal sidetoplaceline 'T)
				(setq colnum (+ colnum 1))
			)
			(
				(equal sidetoplaceline 'B)
				(setq colnum (+ colnum 1))
			)	
		)
	
		(elt (elt linerepmap (- rownum 1)) (- colnum 1))

)


;;------------------------

;;assuming that the dots and tiles are all valid before calling this
(defun isclosedcircut ()

	(cond
		(
			(< linenum 4)
			(setq isboardvalid nil)
		)
		(t
			(findfirstline)		;;firstline will now be set with some 
			(Setq linecount 0)
			(Setq nextline nil)
			(setq currentline nil)
			(findnextline)
			(setq isboardvalid (equal linecount linenum))
			
		)
	)	
	
	isboardvalid	
)


;;------------------------
;;THIS NEEDS TO BE CHANGED
(defun findfirstline ()

	(setq firstline nil)

	(loop for i from 2 to (- (list-length linerepmap) 1) do
		(loop for j from 1 to (list-length (elt linerepmap (- i 1))) do
			(cond
				(
					(equal (car (elt (elt linerepmap (- i 1)) (- j 1)) ) '(line))
					(setq firstline (list (eval i) (eval j)))
					(Setq j (list-length (elt linerepmap (- i 1))))
					(setq i (- (list-length linerepmap) 1))
				)
			)
		)
		
	)
	firstline
)

;;------------------------
;;THIS NEEDS TO BE CHANGED
(defun findnextline ()

	(cond
		(
			(equal linecount 0)
			(setq currentline firstline)
			(setq nextline (car (findlinenexttoyou currentline nil)))
			
			(setq linecount (+ 1 linecount))
			(findnextline)
		)
		(	
			(equal firstline nextline)
			linecount
		)
		(t
			(setq templine (car (findlinenexttoyou nextline currentline)))
			(setq currentline nextline)
			(setq nextline templine)
			(setq linecount (+ 1 linecount))
			(findnextline)
		)
	)
	linecount	
)

;;------------------------
;;THIS NEEDS TO BE CHANGED
(defun findlinenexttoyou (lineyouare linetoomit)

	(if
		(equal (mod (Car lineyouare) 2) 0)
		(Setq linestoreturn
			(findlinenexttoyoueven lineyouare)
		)
		(setq linestoreturn 
			(findlinenexttoyouodd lineyouare)
		)
	)
	(setq linestoreturn (remove linetoomit linestoreturn :test #'equal))
)

;;------------------------
;;THIS NEEDS TO BE CHANGED
(defun findlinenexttoyouodd (lineyouare)

	(setq listtoreturn '())
	
	
	(if
		(returnifline (- (car lineyouare) 1) (cadr lineyouare))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(- (car lineyouare) 1) 
					(cadr lineyouare)
				))
			)
		)
	)
	(if
		(returnifline (+ (car lineyouare) 1) (cadr lineyouare))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(+ (car lineyouare) 1) 
					(cadr lineyouare)
				))
			)
		)
	)
	(if
		(returnifline (- (car lineyouare) 1) (+ 1 (cadr lineyouare)))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(- (car lineyouare) 1) 
					(+ 1 (cadr lineyouare))
				))
			)
		)
	)
	(if
		(returnifline (+ (car lineyouare) 1) (+ 1 (cadr lineyouare)))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(+ (car lineyouare) 1) 
					(+ 1 (cadr lineyouare))
				))
			)
		)
	)
	(if
		(returnifline (+ (car lineyouare) 2) (cadr lineyouare))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(+ (car lineyouare) 2) 
					(cadr lineyouare)
				))
			)
		)
	)
	(if
		(returnifline (- (car lineyouare) 2) (cadr lineyouare))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(- (car lineyouare) 2) 
					(cadr lineyouare)
				))
			)
		)
	)
	listtoreturn
)

;;------------------------
;;THIS NEEDS TO BE CHANGED
(defun findlinenexttoyoueven (lineyouare)

	(setq listtoreturn '())
	
	
	(if
		(returnifline (- (car lineyouare) 1) (cadr lineyouare))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(- (car lineyouare) 1) 
					(cadr lineyouare)
				))
			)
		)
	)
	(if
		(returnifline (+ (car lineyouare) 1) (cadr lineyouare))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(+ (car lineyouare) 1) 
					(cadr lineyouare)
				))
			)
		)
	)
	(if
		(returnifline (- (car lineyouare) 1) (- (cadr lineyouare) 1))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(- (car lineyouare) 1)
					(- (cadr lineyouare) 1)
				))
			)
		)
	)
	(if
		(returnifline (+ (car lineyouare) 1) (- (cadr lineyouare) 1))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(+ (car lineyouare) 1) 
					(- (cadr lineyouare) 1)
				))
			)
		)
	)
	(if
		(returnifline (car lineyouare) (- (cadr lineyouare) 1))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(car lineyouare) 
					(- (cadr lineyouare) 1)
				))
			)
		)
	)
	(if
		(returnifline (car lineyouare) (+ (cadr lineyouare) 1))
		(setq listtoreturn
			(append listtoreturn 
				(list (list
					(car lineyouare) 
					(+ (cadr lineyouare) 1)
				))
			)
		)
	)
	listtoreturn
)

;;------------------------
;;THIS NEEDS TO BE CHANGED
(defun returnifline (rownumber columnnumber)

	(equal (car (elt (elt linerepmap (- rownumber 1)) (- columnnumber 1))) '(line))
)

;;------------------------
(defun statestring ()
	(cond
		( isboardvalid 
			(print "Game is over and the board is correct.")
			maplist
		)
		( t
			(print "Board is still incorrect or not completed.")
		)
	)
)
;;------------------------
(defun dotstring ()
	(if aredotsvalid 
		(print "Intersections are valid")
		(print "Some intersections are not valid")
	)
)
;;------------------------
(defun tilestring ()
	(if aretilesvalid 
		(print "Tiles are valid")
		(print "Some tiles are not valid")
	)
)


;;------------------------

(defun convertlinetocontentrow (number)
	(/ (- number 1) 2 )
)

;;------------------------

(defun convertcontenttolinerow (number)
	(+ (* number 2) 1 )
)


;;------------------------
(defun makemap (mapname mapcontents)

	 (set mapname mapcontents)
	 (setq maplist (append maplist (list mapname)))
 )

;;------------------------

(defun makegameboard (mapname) 

	(setq rownum (list-length (eval mapname)) )
	(setq colnum (list-length (car (eval mapname))))
	(setq linerepmap (makelinerepmap rownum colnum))
	(setq dotrepmap (makedotrepmap linerepmap))
	(setq tilerepmap (maketilerepmap dotrepmap (eval mapname)))
	(setq linenum 0)
	(setq aredotsvalid nil)
	(setq aretilesvalid nil)
	(setq isboardvalid nil)
	(setq movelist '())
	(if (y-or-n-p "Would you like the AI to solve this map?") 
      (cond 
      		(
      			(y-or-n-p "Would you like the map to be printed for every move?") 
      			(Setq ishuman nil) (Setq printingwanted t) (setq isAInotstuck nil)
      		)
      		(t	(Setq ishuman nil) (Setq printingwanted nil) (setq isAInotstuck nil)
      		)
      	)
      	(setq ishuman t)	   
	)
	(setq currentmap (list mapname 'linerepmap 'dotrepmap 'tilerepmap 'movelist 'linenum))
	(string "The game map is now set. Enter (slither) to start the game.")
)



;;------------------------
(defun makelinerepmap (rownum colnum)

	(loop for i from 1 to (+ (* rownum 2) 3) collect
		(cond 
			((or (equal 1 i) (equal (+ (* rownum 2) 3) i))
				(make-sequence 'list (+ 1 colnum) :initial-element '((xx)))
			)
			((equal (mod i 2) 0)
				(if (> (/ i 2) rownum)
					(middleRowBottomLineRepMpa i)
					(middleRowNotBottomLineRepMpa i)
				)
			)
			(t 
				(append 
					(loop for j from 0 to (- colnum 1) collect 
						(list (list 'empty) (list (/ (- i 1) 2) (+ j 1) 'L))
					)
					(list (list (list 'empty) (list (/ (- i 1) 2) colnum 'R)))
				)
			)
		)
	)
)

;;------------------------
(defun middleRowNotBottomLineRepMpa(rrownum)

	(append 
		(list '((xx))) 
		(loop for j from 1 to colnum collect
		(list (list 'empty) (list (/ rrownum 2) j 'T)))
		(list '((xx)))
	)
)

;;------------------------
(defun middleRowBottomLineRepMpa(rrownum)

	(append 
		(list '((xx)))
		(loop for j from 1 to colnum collect
		(list (list 'empty) (list (- (/ rrownum 2) 1) j 'B)))
		(list '((xx)))
	)
)

;;------------------------
(defun createdot (numberrow numbercol linerepmap)		
	(list 
		(elt (elt linerepmap (- numberrow 1)) (- numbercol 1))
	
		(elt (elt linerepmap numberrow) numbercol)
	
		(elt (elt linerepmap (+ numberrow 1)) (- numbercol 1))
	
		(elt (elt linerepmap numberrow) (- numbercol 1))
	)
)

;;------------------------
(defun makedotrepmap (linerepmap)

	(remove nil
		(setq listofdots
			(loop for i from 1 to (- (list-length linerepmap) 1) collect
				(cond
						((equal (equal (mod i 2) 0) NIL)	 	
						
						(loop for j from 1 to (+ 1 colnum) collect
							(createdot i j linerepmap))
						)
				)
			)
		)
	)
)



;;------------------------
(defun maketilerepmap (dotrepmap mapcontents)
 
	(loop for i from 1 to (list-length mapcontents) collect
		(loop for j from 1 to (list-length (car mapcontents)) collect
			(list (elt (elt mapcontents (- i 1)) (- j 1))

			(elt (elt (elt dotrepmap (- i 1)) (- j 1)) 1)

			(elt (elt (elt dotrepmap i) j) 0)
		
			(elt (elt (elt dotrepmap i) j) 3)
		
			(elt (elt (elt dotrepmap (- i 1)) (- j 1)) 2)
			
			)
		)	
	)
 )


;;------------------------

(defun getprintmap (currentmap)

	(setq columnnumbered nil)

		(loop for j from 0 to (- (list-length (car (eval (cadr currentmap)))) 1) do
			(Setq columnnumbered (append columnnumbered (list j '-)))
		)
	
	(setq result
		(loop for i from 2 to (- (list-length (eval (cadr currentmap))) 1) collect
			(cond
				((equal 0 (mod i 2))
				 	(append (list '-)(printevenrow i (cadr currentmap)))
				)
				(t
					(append (list (/ (- i 1) 2))(printoddrow i (cadr currentmap) (car currentmap)))
				)
			)
		)
	)
	
	(setq resultresult (append (list columnnumbered) result))
)

;;------------------------

(defun convertsymboleven (symbol)

	(cond
		((equal '(line) (car symbol))
			'=
		)(t 
			(convertsymbolany symbol)
		)
	)
)

;;------------------------

(defun convertsymbolodd (symbol)

	(cond 
		((equal '(line) (car symbol))
			'i
		)
		(t 
			(convertsymbolany symbol)
		)
	)
)

;;------------------------

(defun convertsymbolany (symbol)
	
	(cond 
		((equal '(xx) symbol) 
			'x
		)
		((equal '(x) (car symbol))
			'x
		)
		((equal '(empty) (car symbol))
			'*
		)
	)
)

;;------------------------

(defun printevenrow (rowtoprint linerepmap)
	(setq lines (mapcar #'convertsymboleven (elt (eval linerepmap) (- rowtoprint 1))
	))
	 
	(setq result '())
	
	(loop for i from 1 to (- (list-length lines) 2) do
		(setq result 
			(append result 
				(list 
					'+
					(elt lines i)
				)
			)
		)
	)
	
	(append result (list '+))
)

;;------------------------

(defun printoddrow (rowtoprint linerepmap mapname)
	(setq symbols 
		(mapcar #'convertsymbolodd 
			(elt (eval linerepmap) (- rowtoprint 1)
			)
		)
	)
	
	(setq mapcontentsrow (elt (eval mapname) (- (convertlinetocontentrow rowtoprint) 1 )))
	
	(setq result '())
	
	(loop for i from 1 to (list-length mapcontentsrow) do
		(setq result 
			(append result 
				(list 
					(elt symbols (- i 1))
					(elt mapcontentsrow (- i 1))
				)
			)
		)
	)
	
	(append result (last symbols 1))
)


;;------------------------

(defun printmap ()

	(setq resultresult (getprintmap currentmap))
	
	
	(loop for i from 0 to (- (list-length resultresult) 1 ) do
		(print (elt resultresult i))
	)
)

;;------------------------
(defun showgamerules ()
	(format t 
"Slither Link's Puzzle Loop is a game of wits, between you and the rules I will describe 
here.

The quote below is from Slither Link's exact description copied from their website:

\"The rules are simple. You have to draw lines between the dots to form a single loop 
without crossings or branches. The numbers indicate how many lines surround it.\"


To accomplish this monumental task, the following wil explain how, coding wise, things 
needed to accomplish such game play by my implementation such as which function calls to 
make, how to construct a map, and specifying moves on the board.


If any questions, comments, or concerns, feel free to contact me:
	Meghan King
	meghantking67@gmail.com

using the subject: Slither's Puzzle Loop Question.



Content sections are in this order:
	Seeing the game rules
	Making a map
	Selecting a map to play
	Printing a map before gameplay
	Starting a game
	Making a move
	Winning the game

==========================================================================================
Seeing the game rules:

	Game rules can be found in the README.txt file paired with the Silther implementation.
	
	Game rules can also be printed once the game is loaded by calling the function
	'showgamerules' which has no arguments
	
		CG-USER(27): (showgamerules)

		The output of this is omitted in this case.

==========================================================================================
Making a map:

	Maps are structured as a a list. Each sublist is the rows, in order from top to
	bottom, with their contents being each element (or tile) in the corresponding column 
	of that row. Tiles that have a number should be specified with that number 
	(0, 1, 2, 3, or 4). Tiles that have no number should be specified with the @ char.

	Once a map is made, the name of the map is added to a list of all the maps created, 
	called 'maplist'. The 'maplist' is returned each time a new map is created.
	To create a map, use the function 'makemap' which takes two arguments:
		1. the name of map
		2. the contents of the map in the correct form
		
	Please only input maps that have a proper solution.



	Example of making a map:

		(+ * + * +) 
		(* 1 * 0 *) 
		(+ * + * +) 
		(* 3 * @ *) 
		(+ * + * +) 
		(* 2 * @ *) 
		(+ * + * +) 

		The map above can be created by entering:

		CG-USER(17): (makemap 'mapexample '((1 0) (3 @) (2 @)))
		(MAP1 MAP2 MAP3 MAP4 MAP5 MAP6 MAPEXAMPLE)
		

==========================================================================================
Selecting a map to play:

	Many maps can be made, but only one map can be the game board at a time. 
	To select a game board, use the function 'makegameboard' with one arguement:
		1. the name of the map
		
			CG-USER(27): (makegameboard 'mapexample)
			
			(+ * + * +) 
			(* 1 * 0 *) 
			(+ * + * +) 
			(* 3 * @ *) 
			(+ * + * +) 
			(* 2 * @ *) 
			(+ * + * +) 
			\"This is now the game map. Enter (slither) to start the game.\"
	
	
==========================================================================================
Printing a map before gameplay:

	A map can be printed with either the contents that were input by the user, or in 
	the format seen in \"Example of making a map\".
	
	To print with the contents input by ther user, enter the name of the map.
	
			CG-USER(17): mapexample
			((1 0) (3 @) (2 @))

	To print with the contents in the playable format, use a function 'printmap' which 
	takes no arguments. 
	However, there MUST be a game board already set using 
	'makegameboard' function.

			CG-USER(37): (printmap)

			(+ * + * +) 
			(* 1 * 0 *) 
			(+ * + * +) 
			(* 3 * @ *) 
			(+ * + * +) 
			(* 2 * @ *) 
			(+ * + * +)


==========================================================================================
Starting a game:

	After selecting a map to play (see the section of the same name above for details),
	use the function 'slither' with no arguments. 
	However, there MUST be a game board already set using 'makegameboard' function.

			CG-USER(38): (slither)

			(+ * + * +) 
			(* 1 * 0 *) 
			(+ * + * +) 
			(* 3 * @ *) 
			(+ * + * +) 
			(* 2 * @ *) 
			(+ * + * +) 
			\"Intersections are valid\" 
			\"Some tiles are not valid\" 
			\"Board is still incorrect or not completed.\" Make another move? y/n: 
			
			
==========================================================================================	
Making a move:

	After starting a game, you will be prompted if you would liek to make another move.
	Entering the character y will allow you to enter a move.
	Entering anything else will allow you to exit the game.
	
			\"Board is still incorrect or not completed.\" Make another move? y/n: y
			Your next move it: 
	
	To enter a move, specify the row number, column number, and the side you would like 
	the lined to be placed (T top, L left, B bottom, R right)
	
			Your next move it: 2 2 L
			
			(+ * + * +) 
			(* 1 * 0 *) 
			(+ * + * +) 
			(* 3 I @ *) 
			(+ * + * +) 
			(* 2 * @ *) 
			(+ * + * +) 
			\"Some intersections are not valid\" 
			\"Some tiles are not valid\" 
			\"Board is still incorrect or not completed.\" Make another move? y/n
	
	This will draw a line in the place that you have specified: 
		the second row, second column, Left side
		
	This same move could have been accomplished with 2 1 R.


==========================================================================================
Restarting a game after exit:

	A game that was currently being played, but you chose to make no more moves (either
	by accident or on purpose) can be reset to the state you left it at by using the
	function 'slither'
	
			CG-USER(23): (slither)

			(+ = + * +) 
			(* 2 * 2 *) 
			(+ * + * +) 
			(* 2 * 2 *) 
			(+ * + * +) 
			\"Some intersections are not valid\" 
			\"Some tiles are not valid\" 
			\"Board is still incorrect or not completed.\" Make another move? y/n: 

==========================================================================================
Winning a game:

	A game is won by completing the board following the Slither's Puzzle Loop rules.
	The game should correctly determine if you have completed the board successfully.
	A dialog box will ask you if you want to play another board. 
	, you will be prompted to ask the play another map.
	A list of all the map names will be printed, and you can enter which map you would 
	like to select.
	
			
			You've won! Do you want to play another board?
			Choose a map: map1 map2 map3 map4 map5 map6 mapexample
			
	Type in the map name, and the process starts all over again.
	
	
================================== Thanks for playing! ==================================")
)



;;------------------------
(setq maplist '())

(makemap 'map1  '((2 2) (2 2)))
(makemap 'map2 '((1 0) (3 @) (2 @)))
(makemap 'map3 '((2 2 @ @ @) (@ 2 @ 2 2) (@ @ 3 @ @) (@ @ 0 @ @) (3 @ 3 @ @)) )
(makemap 'map4 '((4)))
(makemap 'map5 '((@ @) (3 3)))

(makegameboard 'map2)