(defun makemap (mapname mapcontents)

	 (set mapname mapcontents)
	 (setq maplist (append maplist (list mapname)))
 )

;;------------------------

(defun makerepresentations (mapname) 

	(setq rownum (list-length (eval mapname)))
	(setq colnum (list-length (car (eval mapname))))
	(setq linerepmap (makelinerepmap rownum colnum))
	(setq currentmap (list mapname linerepmap rownum colnum))
)



;;------------------------

(defun makelinerepmap (rownum colnum)

	(loop for i from 1 to (+ (* rownum 2) 1) collect
		(cond 
			((or (equal 1 i) (equal (+ (* rownum 2) 1) i))
				(make-sequence 'list (+ 1 colnum) :initial-element 'xx
	)
			)
			((equal (mod i 2) 0)
				(append 
					(list 'xx) 
					(make-sequence 'list colnum :initial-element 'empty) 
					(list 'xx)
				)
			)
			(t 
				(make-sequence 'list (+ colnum 1) :initial-element 'empty
				)
			)
		)
	)
)

;;------------------------
;;unimplemented
(defun makemove (rownum colnum sidetoplaceline)

)

;;------------------------
;;unimplemented

(defun isclosedcircut (lineplacement)
"given a starting line, tests to see if this line is contained in a closed loop"

;;save the original line you are looking at..
;;note: need to keep a line to pass in, maybe last line drawn... ill figure that out later

;;go to the next line in some direction, doesn't matter. keep a count of how many lines you have seen
;;note: if there is not a way to go in both directions, then its not a closed loop

;;if there is no line, not a closed circuit. return false?

;;if there is more than one, DONT LET THAT HAPPEN
;;besides the first time when you need to choose which direction to go in.. (if that doesn’t have two directions than end right there and then…

;;if there is, check if it is the original (points to the same place in memory), if its not, call this on the next line

;;if it is the original, check if the count you have is the same as the overall line count
;;means you have hit all the lines and it is a closed loop

)

;;------------------------
# utilizes
# 	printevenrow
# 		convertsymboleven
# 	printoddrow
# 		convertsymbolodd

(defun printmap (currentmap)

	(loop for i from 2 to (* (caddr currentmap)) collect
		(cond
			((equal 0 (mod i 2))
				(printroweven i (cadr currentmap))
			)
			(t
				(printrowodd i (cadr currentmap))
			)
		)
	)
)

;;------------------------

(defun convertsymboleven (symboltoconvert)

	(cond 
		((equal 'xx symboltoconvert) 
			'x
		)
		((equal 'x symboltoconvert )
			'x
		)
		((equal 'empty symboltoconvert )
			'*
		)
		((equal 'line symboltoconvert )
			'-
		)
	)
)

;;------------------------

(defun convertsymbolodd (symbol)

	(cond 
		((equal 'xx symbol) 
			'x
		)
		((equal 'x symbol) 
			'*
		)
		((equal 'empty symbol)
			'*
		)
		((equal 'line symbol)
			'i
		)
	)
)

;;------------------------

(defun printevenrow (rowtoprint linerepmap)
	(mapcar #'convertsymboleven (elt linerepmap (- rowtoprint 1))
	)
)

;;------------------------

;;NOT FINISHED MEGHAN
	;;prints out odd rows, besides the first and last (probably)
	;;need to splice together the mapcontent rows with these rows...
(defun printoddrow (rowtoprint linerepmap mapcontents)
	(mapcar #'convertsymbolodd (elt linerepmap (- rowtoprint 1))
	)
)

;;------------------------
