;; q: the instructions say there are ways to do moves, should we allow the user to undo a move? like if they input something incorrectly...
;; a: he explicitly says other extra features to be part of the user interface
;; 
;; extra things I may want to add:
;; 	being able to end the map you are on at any time
;;  	being able to clear a line... or undo a move.... clear a line.
;;  	saying that you want an x... nope don't care (i do in back end, but dont print and don't let user do it I guess
;;  	
 
;; Implementation restrictions:
;; 
;; 1	Each move will be specified as a triple – two numbers separated by a blank followed by blank and a letter: N N L. 
;; 	No other punctuation or characters is allowed. 
;; 	The two numbers will identify the row then column (starting in the upper left corner) where a line will be added and the letter will identify the line’s position on the square (T for top, B for bottom, L for left, and R for right)
;; 
;; 2	(e.g., numbering the rows and columns are highly recommended)
;; 
;; 3	Each student will turn in a textual copy of their program 
;; (not compiled) on this date with a README.TXT plain text file describing 
;; how to execute your program. 
;;
;; 4 	The main routine for your program should be called “slither”
;;
;; 5	once a solution is found, the game must ask if you want to play another game, repeating the process of gameplay


;;list of variables to know:
;;rownum -> number of rows in the current map
;;colnum -> number of columns in the current map
;;currentmap -> list containing (mapname linerepmap dotrepmap rownum colnum) of the current map
;;linecount -> the number of lines drawn on the current map
;;maplist -> list containing all the maps predefined in the program currently

;;list of functions to know:
;;isClosedCircut -> given a lineplacement and the linerepmap, will determine if the line is contained in a closed circuit in this map
;;
;;makemap -> creates a puzzle-loop map with name given as first parameter and contents given as second parameter
;;				sets the mapname and adds the maoname to the maplist
;;
;;makerepresentation -> creates reps for currentmap. sets currentmap with mapname linerepmap dotrepmap rownum and colnum. setting all those variables as well
;;

(defun makemap 
(mapname mapcontents)
 "creates a puzzle-loop map with name given as first parameter and contents given as second parameter"
 (set mapname mapcontents)
 (setq maplist (append maplist (list mapname)))
 )

(defun makerepresentations (mapname) 
"create the representations for dotrepmap and linerepmap for the mapcontents passed into the parameters and updates the currentmap"
(setq rownum (list-length (eval mapname)))
(setq colnum (list-length (car (eval mapname))))
(setq dotrepmap (makedotrepmap rownum colnum))
(setq currentmap '(mapname linerepmap dotrepmap rownum colnum))
)

(defun makedotrepmap (rownum colnum)
“create the dot representation of the map”

;; create the empty list itself
;; each element is a list of 4 elements.. the top right bottom left, in that order
;; 
;; loop should:
;; 
;; create a list
;; 
;; assign top
;; assign right
;; assign bottom
;; assign left
;; 
;; add to correct sublist
;; 
;; increment currentrow/colnum
;; go to next element (to the right… sure or next line) until you run out

;; keep track of column number and row number
(setq currentrownum 0)
(seta currentcolnum 0)

;; create a list
(list …


;; if not on top set top to cddar (or cddaar) of element above
;; if on top assign top to never
(cond 
((equal currentrownum 0) nil)
(t (cddar dotmaprep))
)
;; if on right side assign right to never
;; if not on right side assign right one to empty
(cond
((equal currentcolnum colnum) nil)
(t empty)
)

;; if not on bottom assign bottom to empty
;; if on bottom assign bottom to never
(cond
((equal currentrownum rownum) nil)
(t empty)
)
;; if on left side assign left to never
;; if not on left set left to cdar (or cdaar) of element before
(cond
((equal currentcolnum 0) nil)
(t (cdar of element before this one...))
)
;; use row numbers and column numbers to iterate to that exact element... which i should have a general function to do this anyways because the game will be like that always...
)



(defun makemove (rownum colnum sidetoplaceline)
"allows a line to be drawn on the map given the placement of the line"

)



(defun isclosedcircut (lineplacement)
"given a starting line, tests to see if this line is contained in a closed loop"

;;save the original line you are looking at..
;;note: need to keep a line to pass in, maybe last line drawn... ill figure that out later

;;go to the next line in some direction, doesn't matter. keep a count of how many lines you have seen
;;note: if there is not a way to go in both directions, then its not a closed loop

;;if there is no line, not a closed circuit. return false?

;;if there is more than one, DONT LET THAT HAPPEN
;;besides the first time when you need to choose which direction to go in.. (if that doesn’t have two directions than end right there and then…

;;if there is, check if it is the original (points to the same place in memory), if its not, call this on the next line

;;if it is the original, check if the count you have is the same as the overall line count
;;means you have hit all the lines and it is a closed loop

)

(defun printmap (currentmaps)
"given a currentmaps object, will print out the map and line representation of the current map. with row and columns numbered"

)


;; how to represent the lines and dots and all that shit
;; have all the dots, each has 4 lines
;; have a square, each having the representations it can have along with the 4 dots that it is associated with..
;; representations are gonna be... mad hard to do... like I think yeah


