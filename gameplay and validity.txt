
;;------------------------

(defun makemove (rownum colnum sidetoplaceline)
	
	(setq lineinquestion (getplacementreference rownum colnum sidetoplaceline))
	
	(rplaca placementtocheck 'line)
	
	(checkdots dotrepmap) (checktiles tilerepmap)
	
	(setq linenum (+ 1 linenum))
	(setq movelist (append movelist (list (list rownum colnum sidetoplaceline))))
	
	;;(setq isplacingonempty (isplacingonempty lineinquestion))
	
	(printmap currentmap)
)	

(defun checkdots (dotrepmap)

	(resetaredotsvalid)	
			
	(loop for i from 1 to (list-length dotrepmap) collect
		(mapcar #'checkdot (elt dotrepmap (- i 1)))

	)
			
	aredotsvalid
)

(defun checktiles (tilerepmap)

	(resetaretilesvalid)

	(loop for i from 1 to (list-length tilerepmap) collect
		(mapcar #'checktile (elt tilerepmap (- i 1)))

	)

	aretilesvalid
)



;;------------------------
;;(defun isvalidplacement ( )

;;)

(defun resetaredotsvalid ()

(setq aredotsvalid t)

)

(defun aredotsvalid ( isitthough)

(setq aredotsvalid (and isitthough aredotsvalid))

)

(defun resetaretilesvalid ()

(setq aretilesvalid t)

)

(defun aretilesvalid ( isitthough)

(setq aretilesvalid (and isitthough aretilesvalid))

)



(defun checkdot ( dottocheck )

	(setq countoflines (count '(line) dottocheck :test #'equal))
	(setq countofxs ( + (count '(xx) dottocheck :test #'equal) (count '(x) dottocheck :test #'equal)))
	(setq countofemptys (count '(empty) dottocheck :test #'equal))

	(cond
		(
			(equal countoflines 4) 
			;;BAD
			(aredotsvalid nil)
		)
		(
			(equal countoflines 3) 
			;;BAD
			(aredotsvalid nil)
		)
		(
			(equal countoflines 2)
			;;OKAY
			;;if some empty spots
			;;set all the other lines to x's
			(aredotsvalid t)
		)
		(
			(equal countoflines 1)
			 ;;BAD
			 (aredotsvalid nil)
		)
		(
			t
			;;OKAY
			;;if has any x's, set all the lines to x's
			(aredotsvalid t)
		)
	)	
)

(defun checktile ( tiletocheck )

	(setq numberintile (car tiletocheck))
	
	(setq countoflines (count '(line) tiletocheck :test #'equal))
	(setq countofxs ( + (count '(xx) tiletocheck :test #'equal) (count '(x) tiletocheck :test #'equal)))
	(setq countofemptys (count '(empty) tiletocheck :test #'equal))

	(cond
		(
			(equal countoflines numberintile) 
			;;GOOD
			;;is some empty spots
			;;set all the other lines to x's
			(aretilesvalid t)
		)
		(
			(< countoflines numberintile) 
			;;can be good or bad or ugly
			
			(cond
				((equal countofemptys (- numberintile countoflines))
					;;GOOD
					;;is some empty spots
					;;set all the other lines to x's
					(aretilesvalid nil)
				)
				((> countofemptys 0)
					;;fine
					(aretilesvalid nil)
				)
				(t
					;;if all others are x's
					;;BAD
					;;which could happen because corners or something
					;;bad juju
					(aretilesvalid nil)
				)
			)
		)
		(
			t
			;;BAD
			;;CANNOT HELP
			;;BAD BAD BAD
			(aretilesvalid nil)
		)
	)	
)

;;------------------------

(defun getplacementreference( rownum colnum sidetoplaceline ) 

		(setq rownum (convertcontenttolinerow rownum))
		
	
		(cond
			(
				(equal sidetoplaceline 'T)
				(setq rownum (- rownum 1))
			)
			(
				(equal sidetoplaceline 'B)
				(setq rownum (+ rownum 1))
			)		
		)
	
		(cond
			(
				(equal sidetoplaceline 'R)
				(setq  colnum (+ colnum 1))
			)
			(
				(equal sidetoplaceline 'T)
				(setq colnum (+ colnum 1))
			)
			(
				(equal sidetoplaceline 'B)
				(setq colnum (+ colnum 1))
			)	
		)
	
		(elt (elt linerepmap (- rownum 1)) (- colnum 1))

)

;;------------------------

(defun getaffecteddots ( linerownum linecolnum )



)

;;------------------------

(defun checkvaliddot ( dottovalidate )


)

;;------------------------
# (defun isplacingonempty( placementtocheck )
# 
# 	(cond
# 		(
# 			(equal placementtocheck '(empty))
# 			(linestring "Valid move!") 
# 			(rplaca placementtocheck 'line)
# 		)
# 	)
# 
# )

;;------------------------
;;unimplemented

;;(defun isclosedcircut ()


;;check the tiles before you check this! precondition to calling this... yes
(cond
	((equal linenum 0)
		t
		(
	)
		

;;"given a starting line, tests to see if this line is contained in a closed loop"

;;save the original line you are looking at..
;;note: need to keep a line to pass in, maybe last line drawn... ill figure that out later

;;go to the next line in some direction, doesn't matter. keep a count of how many lines you have seen
;;note: if there is not a way to go in both directions, then its not a closed loop

;;if there is no line, not a closed circuit. return false?

;;if there is more than one, DONT LET THAT HAPPEN
;;besides the first time when you need to choose which direction to go in.. (if that doesn’t have two directions than end right there and then…

;;if there is, check if it is the original (points to the same place in memory), if its not, call this on the next line

;;if it is the original, check if the count you have is the same as the overall line count
;;means you have hit all the lines and it is a closed loop

;;)



;;------------------------
	;;unimplemented for now
	;;will inform the user of
		;;bad move
		;;make another move
		;;game is over

(defun statestring ()
	(cond
		( isboardvalid 
			(print "Game is over and correct. Pick another map")
			maplist
		)
		( t
			(print "Board is still incorrect or not completed. Make another move?")
		)
	)
)

;; (defun linestring (stringtoline)
;; 	(if aredotsvalid 
;; 		(string "Intersections are valid")
;; 		(string "Intersections are not valid")
;; 	)
;; )

(defun dotstring ()
	(if aredotsvalid 
		(print "Intersections are valid")
		(print "Some intersections are not valid")
	)
)

(defun tilestring ()
	(if aretilesvalid 
		(print "Tiles are valid")
		(print "Some tiles are not valid")
	)
)